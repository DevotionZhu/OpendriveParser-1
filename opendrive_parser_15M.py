#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Aug  7 16:15:15 2019 by generateDS.py version 2.33.1.
# Python 3.7.3 (default, Mar 27 2019, 22:11:17)  [GCC 7.3.0]
#
# Command line options:
#   ('-o', 'opendrive_parser_15M.py')
#
# Command line arguments:
#   OpenDRIVE_1.5M.xsd
#
# Command line:
#   /home/wanhy/miniconda3/envs/carla/bin/generateDS.py -o "opendrive_parser_15M.py" OpenDRIVE_1.5M.xsd
#
# Current working directory (os.getcwd()):
#   Entries
#

import os
import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires integer: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires float or double: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires sequence of floats')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return input_data
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires float or double: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'requires boolean')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class e_accessRestrictionType(Enum):
    SIMULATOR='simulator'
    AUTONOMOUS_TRAFFIC='autonomousTraffic'
    PEDESTRIAN='pedestrian'
    PASSENGER_CAR='passengerCar'
    BUS='bus'
    DELIVERY='delivery'
    EMERGENCY='emergency'
    TAXI='taxi'
    THROUGH_TRAFFIC='throughTraffic'
    TRUCK='truck'
    BICYCLE='bicycle'
    MOTORCYCLE='motorcycle'
    NONE='none'
    TRUCKS='trucks'


class e_borderType(Enum):
    CONCRETE='concrete'
    CURB='curb'


class e_bridgeType(Enum):
    CONCRETE='concrete'
    STEEL='steel'
    BRICK='brick'
    WOOD='wood'


class e_contactPoint(Enum):
    START='start'
    END='end'


class e_countryCode_deprecated(Enum):
    OPEN_DRIVE='OpenDRIVE'
    AUSTRIA='Austria'
    BRAZIL='Brazil'
    CHINA='China'
    FRANCE='France'
    GERMANY='Germany'
    ITALY='Italy'
    SWITZERLAND='Switzerland'
    USA='USA'


class e_dataQuality_RawData_PostProcessing(Enum):
    RAW='raw'
    CLEANED='cleaned'
    PROCESSED='processed'
    FUSED='fused'


class e_dataQuality_RawData_Source(Enum):
    SENSOR='sensor'
    CADASTER='cadaster'
    CUSTOM='custom'


class e_direction(Enum):
    SAME='same'
    OPPOSITE='opposite'


class e_elementDir(Enum):
    _='+'
    __1='-'


class e_junctionGroup_type(Enum):
    ROUNDABOUT='roundabout'
    UNKNOWN='unknown'


class e_junction_type(Enum):
    DEFAULT='default'
    VIRTUAL='virtual'


class e_laneType(Enum):
    NONE='none'
    DRIVING='driving'
    STOP='stop'
    SHOULDER='shoulder'
    BIKING='biking'
    SIDEWALK='sidewalk'
    BORDER='border'
    RESTRICTED='restricted'
    PARKING='parking'
    BIDIRECTIONAL='bidirectional'
    MEDIAN='median'
    SPECIAL_1='special1'
    SPECIAL_2='special2'
    SPECIAL_3='special3'
    ROAD_WORKS='roadWorks'
    TRAM='tram'
    RAIL='rail'
    ENTRY='entry'
    EXIT='exit'
    OFF_RAMP='offRamp'
    ON_RAMP='onRamp'
    CONNECTING_RAMP='connectingRamp'
    BUS='bus'
    TAXI='taxi'
    HOV='HOV'
    MWY_ENTRY='mwyEntry'
    MWY_EXIT='mwyExit'


class e_maxSpeedString(Enum):
    NOLIMIT='no limit'
    UNDEFINED='undefined'


class e_objectType(Enum):
    NONE='none'
    OBSTACLE='obstacle'
    CAR='car'
    POLE='pole'
    TREE='tree'
    VEGETATION='vegetation'
    BARRIER='barrier'
    BUILDING='building'
    PARKING_SPACE='parkingSpace'
    PATCH='patch'
    RAILING='railing'
    TRAFFIC_ISLAND='trafficIsland'
    CROSSWALK='crosswalk'
    STREET_LAMP='streetLamp'
    GANTRY='gantry'
    SOUND_BARRIER='soundBarrier'
    TRUCK='truck'
    VAN='van'
    BUS='bus'
    TRAILER='trailer'
    BIKE='bike'
    MOTORBIKE='motorbike'
    TRAM='tram'
    TRAIN='train'
    PEDESTRIAN='pedestrian'
    WIND='wind'


class e_orientation(Enum):
    _='+'
    __1='-'
    NONE='none'


class e_outlineFillType(Enum):
    GRASS='grass'
    CONCRETE='concrete'
    COBBLE='cobble'
    ASPHALT='asphalt'
    PAVEMENT='pavement'
    GRAVEL='gravel'
    SOIL='soil'


class e_paramPoly3_pRange(Enum):
    ARC_LENGTH='arcLength'
    NORMALIZED='normalized'


class e_roadMarkColor(Enum):
    STANDARD='standard'
    BLUE='blue'
    GREEN='green'
    RED='red'
    WHITE='white'
    YELLOW='yellow'
    ORANGE='orange'


class e_roadMarkRule(Enum):
    NOPASSING='no passing'
    CAUTION='caution'
    NONE='none'


class e_roadMarkType(Enum):
    NONE='none'
    SOLID='solid'
    BROKEN='broken'
    SOLIDSOLID='solid solid'
    SOLIDBROKEN='solid broken'
    BROKENSOLID='broken solid'
    BROKENBROKEN='broken broken'
    BOTTSDOTS='botts dots'
    GRASS='grass'
    CURB='curb'
    CUSTOM='custom'
    EDGE='edge'


class e_roadMarkWeight(Enum):
    STANDARD='standard'
    BOLD='bold'


class e_roadType(Enum):
    UNKNOWN='unknown'
    RURAL='rural'
    MOTORWAY='motorway'
    TOWN='town'
    LOW_SPEED='lowSpeed'
    PEDESTRIAN='pedestrian'
    BICYCLE='bicycle'
    TOWN_EXPRESSWAY='townExpressway'
    TOWN_COLLECTOR='townCollector'
    TOWN_ARTERIAL='townArterial'
    TOWN_PRIVATE='townPrivate'
    TOWN_LOCAL='townLocal'
    TOWN_PLAY_STREET='townPlayStreet'


class e_road_lanes_laneSection_lcr_lane_roadMark_laneChange(Enum):
    INCREASE='increase'
    DECREASE='decrease'
    BOTH='both'
    NONE='none'


class e_road_lanes_laneSection_lr_lane_access_rule(Enum):
    ALLOW='allow'
    DENY='deny'


class e_road_lateralProfile_crossfall_side(Enum):
    LEFT='left'
    RIGHT='right'
    BOTH='both'


class e_road_link_elementType(Enum):
    ROAD='road'
    JUNCTION='junction'


class e_road_link_neighbor_side(Enum):
    LEFT='left'
    RIGHT='right'


class e_road_objects_object_parkingSpace_access(Enum):
    ALL='all'
    CAR='car'
    WOMEN='women'
    HANDICAPPED='handicapped'
    BUS='bus'
    TRUCK='truck'
    ELECTRIC='electric'
    RESIDENTS='residents'


class e_road_railroad_switch_position(Enum):
    DYNAMIC='dynamic'
    STRAIGHT='straight'
    TURN='turn'


class e_road_signals_signal_reference_elementType(Enum):
    OBJECT='object'
    SIGNAL='signal'


class e_road_surface_CRG_mode(Enum):
    ATTACHED='attached'
    ATTACHED_0='attached0'
    GENUINE='genuine'
    GLOBAL='global'


class e_road_surface_CRG_purpose(Enum):
    ELEVATION='elevation'
    FRICTION='friction'


class e_sideType(Enum):
    LEFT='left'
    RIGHT='right'
    FRONT='front'
    REAR='rear'


class e_station_platform_segment_side(Enum):
    LEFT='left'
    RIGHT='right'


class e_station_type(Enum):
    SMALL='small'
    MEDIUM='medium'
    LARGE='large'


class e_trafficRule(Enum):
    RHT='RHT'
    LHT='LHT'


class e_tunnelType(Enum):
    STANDARD='standard'
    UNDERPASS='underpass'


class e_unitDistance(Enum):
    M='m'
    KM='km'
    FT='ft'
    MILE='mile'


class e_unitMass(Enum):
    KG='kg'
    T='t'


class e_unitSlope(Enum):
    _='%'


class e_unitSpeed(Enum):
    MS='m/s'
    MPH='mph'
    KMH='km/h'


class t_bool(Enum):
    TRUE='true'
    FALSE='false'


class t_yesNo(Enum):
    YES='yes'
    NO='no'


class OpenDRIVE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, header=None, road=None, controller=None, junction=None, junctionGroup=None, station=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.header = header
        self.header_nsprefix_ = None
        if road is None:
            self.road = []
        else:
            self.road = road
        self.road_nsprefix_ = None
        if controller is None:
            self.controller = []
        else:
            self.controller = controller
        self.controller_nsprefix_ = None
        if junction is None:
            self.junction = []
        else:
            self.junction = junction
        self.junction_nsprefix_ = None
        if junctionGroup is None:
            self.junctionGroup = []
        else:
            self.junctionGroup = junctionGroup
        self.junctionGroup_nsprefix_ = None
        if station is None:
            self.station = []
        else:
            self.station = station
        self.station_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenDRIVE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenDRIVE.subclass:
            return OpenDRIVE.subclass(*args_, **kwargs_)
        else:
            return OpenDRIVE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_header(self):
        return self.header
    def set_header(self, header):
        self.header = header
    def get_road(self):
        return self.road
    def set_road(self, road):
        self.road = road
    def add_road(self, value):
        self.road.append(value)
    def insert_road_at(self, index, value):
        self.road.insert(index, value)
    def replace_road_at(self, index, value):
        self.road[index] = value
    def get_controller(self):
        return self.controller
    def set_controller(self, controller):
        self.controller = controller
    def add_controller(self, value):
        self.controller.append(value)
    def insert_controller_at(self, index, value):
        self.controller.insert(index, value)
    def replace_controller_at(self, index, value):
        self.controller[index] = value
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def add_junction(self, value):
        self.junction.append(value)
    def insert_junction_at(self, index, value):
        self.junction.insert(index, value)
    def replace_junction_at(self, index, value):
        self.junction[index] = value
    def get_junctionGroup(self):
        return self.junctionGroup
    def set_junctionGroup(self, junctionGroup):
        self.junctionGroup = junctionGroup
    def add_junctionGroup(self, value):
        self.junctionGroup.append(value)
    def insert_junctionGroup_at(self, index, value):
        self.junctionGroup.insert(index, value)
    def replace_junctionGroup_at(self, index, value):
        self.junctionGroup[index] = value
    def get_station(self):
        return self.station
    def set_station(self, station):
        self.station = station
    def add_station(self, value):
        self.station.append(value)
    def insert_station_at(self, index, value):
        self.station.insert(index, value)
    def replace_station_at(self, index, value):
        self.station[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.header is not None or
            self.road or
            self.controller or
            self.junction or
            self.junctionGroup or
            self.station or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenDRIVE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OpenDRIVE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OpenDRIVE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OpenDRIVE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OpenDRIVE'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenDRIVE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            namespaceprefix_ = self.header_nsprefix_ + ':' if (UseCapturedNS_ and self.header_nsprefix_) else ''
            self.header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='header', pretty_print=pretty_print)
        for road_ in self.road:
            namespaceprefix_ = self.road_nsprefix_ + ':' if (UseCapturedNS_ and self.road_nsprefix_) else ''
            road_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='road', pretty_print=pretty_print)
        for controller_ in self.controller:
            namespaceprefix_ = self.controller_nsprefix_ + ':' if (UseCapturedNS_ and self.controller_nsprefix_) else ''
            controller_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controller', pretty_print=pretty_print)
        for junction_ in self.junction:
            namespaceprefix_ = self.junction_nsprefix_ + ':' if (UseCapturedNS_ and self.junction_nsprefix_) else ''
            junction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junction', pretty_print=pretty_print)
        for junctionGroup_ in self.junctionGroup:
            namespaceprefix_ = self.junctionGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.junctionGroup_nsprefix_) else ''
            junctionGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junctionGroup', pretty_print=pretty_print)
        for station_ in self.station:
            namespaceprefix_ = self.station_nsprefix_ + ':' if (UseCapturedNS_ and self.station_nsprefix_) else ''
            station_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='station', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = t_header.factory(parent_object_=self)
            obj_.build(child_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'road':
            obj_ = t_road.factory(parent_object_=self)
            obj_.build(child_)
            self.road.append(obj_)
            obj_.original_tagname_ = 'road'
        elif nodeName_ == 'controller':
            obj_ = t_controller.factory(parent_object_=self)
            obj_.build(child_)
            self.controller.append(obj_)
            obj_.original_tagname_ = 'controller'
        elif nodeName_ == 'junction':
            obj_ = t_junction.factory(parent_object_=self)
            obj_.build(child_)
            self.junction.append(obj_)
            obj_.original_tagname_ = 'junction'
        elif nodeName_ == 'junctionGroup':
            obj_ = t_junctionGroup.factory(parent_object_=self)
            obj_.build(child_)
            self.junctionGroup.append(obj_)
            obj_.original_tagname_ = 'junctionGroup'
        elif nodeName_ == 'station':
            obj_ = t_station.factory(parent_object_=self)
            obj_.build(child_)
            self.station.append(obj_)
            obj_.original_tagname_ = 'station'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class OpenDRIVE


class t_header(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, revMajor=1, revMinor=5, name=None, version=None, date=None, north=None, south=None, east=None, west=None, vendor=None, geoReference=None, offset=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.revMajor = _cast(int, revMajor)
        self.revMajor_nsprefix_ = None
        self.revMinor = _cast(int, revMinor)
        self.revMinor_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(float, version)
        self.version_nsprefix_ = None
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.north = _cast(float, north)
        self.north_nsprefix_ = None
        self.south = _cast(float, south)
        self.south_nsprefix_ = None
        self.east = _cast(float, east)
        self.east_nsprefix_ = None
        self.west = _cast(float, west)
        self.west_nsprefix_ = None
        self.vendor = _cast(None, vendor)
        self.vendor_nsprefix_ = None
        self.geoReference = geoReference
        self.geoReference_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header.subclass:
            return t_header.subclass(*args_, **kwargs_)
        else:
            return t_header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geoReference(self):
        return self.geoReference
    def set_geoReference(self, geoReference):
        self.geoReference = geoReference
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_revMajor(self):
        return self.revMajor
    def set_revMajor(self, revMajor):
        self.revMajor = revMajor
    def get_revMinor(self):
        return self.revMinor
    def set_revMinor(self, revMinor):
        self.revMinor = revMinor
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_north(self):
        return self.north
    def set_north(self, north):
        self.north = north
    def get_south(self):
        return self.south
    def set_south(self, south):
        self.south = south
    def get_east(self):
        return self.east
    def set_east(self, east):
        self.east = east
    def get_west(self):
        return self.west
    def set_west(self, west):
        self.west = west
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def validate_t_header_Version(self, value):
        # Validate type t_header_Version, a restriction on xs:float.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_t_header_Version_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_t_header_Version_patterns_, ))
    validate_t_header_Version_patterns_ = [['^(\\d\\.\\d{2})$']]
    def hasContent_(self):
        if (
            self.geoReference is not None or
            self.offset is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header'):
        if 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            outfile.write(' revMajor="%s"' % self.gds_format_integer(self.revMajor, input_name='revMajor'))
        if 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            outfile.write(' revMinor="%s"' % self.gds_format_integer(self.revMinor, input_name='revMinor'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if self.north is not None and 'north' not in already_processed:
            already_processed.add('north')
            outfile.write(' north="%s"' % self.gds_format_double(self.north, input_name='north'))
        if self.south is not None and 'south' not in already_processed:
            already_processed.add('south')
            outfile.write(' south="%s"' % self.gds_format_double(self.south, input_name='south'))
        if self.east is not None and 'east' not in already_processed:
            already_processed.add('east')
            outfile.write(' east="%s"' % self.gds_format_double(self.east, input_name='east'))
        if self.west is not None and 'west' not in already_processed:
            already_processed.add('west')
            outfile.write(' west="%s"' % self.gds_format_double(self.west, input_name='west'))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geoReference is not None:
            namespaceprefix_ = self.geoReference_nsprefix_ + ':' if (UseCapturedNS_ and self.geoReference_nsprefix_) else ''
            self.geoReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geoReference', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('revMajor', node)
        if value is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            try:
                self.revMajor = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('revMinor', node)
        if value is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            try:
                self.revMinor = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
            self.validate_t_header_Version(self.version)    # validate type t_header_Version
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('north', node)
        if value is not None and 'north' not in already_processed:
            already_processed.add('north')
            try:
                self.north = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (north): %s' % exp)
        value = find_attr_value_('south', node)
        if value is not None and 'south' not in already_processed:
            already_processed.add('south')
            try:
                self.south = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (south): %s' % exp)
        value = find_attr_value_('east', node)
        if value is not None and 'east' not in already_processed:
            already_processed.add('east')
            try:
                self.east = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (east): %s' % exp)
        value = find_attr_value_('west', node)
        if value is not None and 'west' not in already_processed:
            already_processed.add('west')
            try:
                self.west = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (west): %s' % exp)
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geoReference':
            obj_ = t_header_GeoReference.factory(parent_object_=self)
            obj_.build(child_)
            self.geoReference = obj_
            obj_.original_tagname_ = 'geoReference'
        elif nodeName_ == 'offset':
            obj_ = t_header_Offset.factory(parent_object_=self)
            obj_.build(child_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_header


class t_header_GeoReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, userData=None, include=None, dataQuality=None, valueOf_=None, mixedclass_=None, content_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header_GeoReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header_GeoReference.subclass:
            return t_header_GeoReference.subclass(*args_, **kwargs_)
        else:
            return t_header_GeoReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_GeoReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header_GeoReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_GeoReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header_GeoReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header_GeoReference'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_GeoReference', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'userData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_userData'):
              self.add_userData(obj_.value)
            elif hasattr(self, 'set_userData'):
              self.set_userData(obj_.value)
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'include', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_include'):
              self.add_include(obj_.value)
            elif hasattr(self, 'set_include'):
              self.set_include(obj_.value)
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dataQuality', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dataQuality'):
              self.add_dataQuality(obj_.value)
            elif hasattr(self, 'set_dataQuality'):
              self.set_dataQuality(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class t_header_GeoReference


class t_header_Offset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, z=None, hdg=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header_Offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header_Offset.subclass:
            return t_header_Offset.subclass(*args_, **kwargs_)
        else:
            return t_header_Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    def get_hdg(self):
        return self.hdg
    def set_hdg(self, hdg):
        self.hdg = hdg
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_Offset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header_Offset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_Offset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header_Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header_Offset'):
        if 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_float(self.hdg, input_name='hdg'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_Offset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            try:
                self.z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            try:
                self.hdg = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hdg): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_header_Offset


class t_road(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, length=None, id=None, junction=None, rule=None, link=None, type_=None, planView=None, elevationProfile=None, lateralProfile=None, lanes=None, objects=None, signals=None, surface=None, railroad=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.junction = _cast(None, junction)
        self.junction_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        self.type__nsprefix_ = None
        self.planView = planView
        self.planView_nsprefix_ = None
        self.elevationProfile = elevationProfile
        self.elevationProfile_nsprefix_ = None
        self.lateralProfile = lateralProfile
        self.lateralProfile_nsprefix_ = None
        self.lanes = lanes
        self.lanes_nsprefix_ = None
        self.objects = objects
        self.objects_nsprefix_ = None
        self.signals = signals
        self.signals_nsprefix_ = None
        self.surface = surface
        self.surface_nsprefix_ = None
        self.railroad = railroad
        self.railroad_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road.subclass:
            return t_road.subclass(*args_, **kwargs_)
        else:
            return t_road(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def add_type(self, value):
        self.type_.append(value)
    def insert_type_at(self, index, value):
        self.type_.insert(index, value)
    def replace_type_at(self, index, value):
        self.type_[index] = value
    def get_planView(self):
        return self.planView
    def set_planView(self, planView):
        self.planView = planView
    def get_elevationProfile(self):
        return self.elevationProfile
    def set_elevationProfile(self, elevationProfile):
        self.elevationProfile = elevationProfile
    def get_lateralProfile(self):
        return self.lateralProfile
    def set_lateralProfile(self, lateralProfile):
        self.lateralProfile = lateralProfile
    def get_lanes(self):
        return self.lanes
    def set_lanes(self, lanes):
        self.lanes = lanes
    def get_objects(self):
        return self.objects
    def set_objects(self, objects):
        self.objects = objects
    def get_signals(self):
        return self.signals
    def set_signals(self, signals):
        self.signals = signals
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_railroad(self):
        return self.railroad
    def set_railroad(self, railroad):
        self.railroad = railroad
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_trafficRule(self, value):
        # Validate type e_trafficRule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RHT', 'LHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_trafficRule' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.link is not None or
            self.type_ or
            self.planView is not None or
            self.elevationProfile is not None or
            self.lateralProfile is not None or
            self.lanes is not None or
            self.objects is not None or
            self.signals is not None or
            self.surface is not None or
            self.railroad is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'junction' not in already_processed:
            already_processed.add('junction')
            outfile.write(' junction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.junction), input_name='junction')), ))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for type_ in self.type_:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.planView is not None:
            namespaceprefix_ = self.planView_nsprefix_ + ':' if (UseCapturedNS_ and self.planView_nsprefix_) else ''
            self.planView.export(outfile, level, namespaceprefix_, namespacedef_='', name_='planView', pretty_print=pretty_print)
        if self.elevationProfile is not None:
            namespaceprefix_ = self.elevationProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.elevationProfile_nsprefix_) else ''
            self.elevationProfile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elevationProfile', pretty_print=pretty_print)
        if self.lateralProfile is not None:
            namespaceprefix_ = self.lateralProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.lateralProfile_nsprefix_) else ''
            self.lateralProfile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lateralProfile', pretty_print=pretty_print)
        if self.lanes is not None:
            namespaceprefix_ = self.lanes_nsprefix_ + ':' if (UseCapturedNS_ and self.lanes_nsprefix_) else ''
            self.lanes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lanes', pretty_print=pretty_print)
        if self.objects is not None:
            namespaceprefix_ = self.objects_nsprefix_ + ':' if (UseCapturedNS_ and self.objects_nsprefix_) else ''
            self.objects.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objects', pretty_print=pretty_print)
        if self.signals is not None:
            namespaceprefix_ = self.signals_nsprefix_ + ':' if (UseCapturedNS_ and self.signals_nsprefix_) else ''
            self.signals.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signals', pretty_print=pretty_print)
        if self.surface is not None:
            namespaceprefix_ = self.surface_nsprefix_ + ':' if (UseCapturedNS_ and self.surface_nsprefix_) else ''
            self.surface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surface', pretty_print=pretty_print)
        if self.railroad is not None:
            namespaceprefix_ = self.railroad_nsprefix_ + ':' if (UseCapturedNS_ and self.railroad_nsprefix_) else ''
            self.railroad.export(outfile, level, namespaceprefix_, namespacedef_='', name_='railroad', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('junction', node)
        if value is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            self.junction = value
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_trafficRule(self.rule)    # validate type e_trafficRule
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'link':
            obj_ = t_road_link.factory(parent_object_=self)
            obj_.build(child_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'type':
            obj_ = t_road_type.factory(parent_object_=self)
            obj_.build(child_)
            self.type_.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'planView':
            obj_ = t_road_planView.factory(parent_object_=self)
            obj_.build(child_)
            self.planView = obj_
            obj_.original_tagname_ = 'planView'
        elif nodeName_ == 'elevationProfile':
            obj_ = t_road_elevationProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.elevationProfile = obj_
            obj_.original_tagname_ = 'elevationProfile'
        elif nodeName_ == 'lateralProfile':
            obj_ = t_road_lateralProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.lateralProfile = obj_
            obj_.original_tagname_ = 'lateralProfile'
        elif nodeName_ == 'lanes':
            obj_ = t_road_lanes.factory(parent_object_=self)
            obj_.build(child_)
            self.lanes = obj_
            obj_.original_tagname_ = 'lanes'
        elif nodeName_ == 'objects':
            obj_ = t_road_objects.factory(parent_object_=self)
            obj_.build(child_)
            self.objects = obj_
            obj_.original_tagname_ = 'objects'
        elif nodeName_ == 'signals':
            obj_ = t_road_signals.factory(parent_object_=self)
            obj_.build(child_)
            self.signals = obj_
            obj_.original_tagname_ = 'signals'
        elif nodeName_ == 'surface':
            obj_ = t_road_surface.factory(parent_object_=self)
            obj_.build(child_)
            self.surface = obj_
            obj_.original_tagname_ = 'surface'
        elif nodeName_ == 'railroad':
            obj_ = t_road_railroad.factory(parent_object_=self)
            obj_.build(child_)
            self.railroad = obj_
            obj_.original_tagname_ = 'railroad'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road


class t_road_link(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, predecessor=None, successor=None, neighbor=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if neighbor is None:
            self.neighbor = []
        else:
            self.neighbor = neighbor
        self.neighbor_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_link.subclass:
            return t_road_link.subclass(*args_, **kwargs_)
        else:
            return t_road_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predecessor(self):
        return self.predecessor
    def set_predecessor(self, predecessor):
        self.predecessor = predecessor
    def get_successor(self):
        return self.successor
    def set_successor(self, successor):
        self.successor = successor
    def get_neighbor(self):
        return self.neighbor
    def set_neighbor(self, neighbor):
        self.neighbor = neighbor
    def add_neighbor(self, value):
        self.neighbor.append(value)
    def insert_neighbor_at(self, index, value):
        self.neighbor.insert(index, value)
    def replace_neighbor_at(self, index, value):
        self.neighbor[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.neighbor or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_link'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for neighbor_ in self.neighbor:
            namespaceprefix_ = self.neighbor_nsprefix_ + ':' if (UseCapturedNS_ and self.neighbor_nsprefix_) else ''
            neighbor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='neighbor', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'predecessor':
            obj_ = t_road_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = t_road_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'neighbor':
            obj_ = t_road_link_neighbor.factory(parent_object_=self)
            obj_.build(child_)
            self.neighbor.append(obj_)
            obj_.original_tagname_ = 'neighbor'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_link


class t_road_link_predecessorSuccessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, elementType=None, elementId=None, contactPoint=None, elementS=None, elementDir=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
        self.elementS = _cast(float, elementS)
        self.elementS_nsprefix_ = None
        self.elementDir = _cast(None, elementDir)
        self.elementDir_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_link_predecessorSuccessor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_link_predecessorSuccessor.subclass:
            return t_road_link_predecessorSuccessor.subclass(*args_, **kwargs_)
        else:
            return t_road_link_predecessorSuccessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_elementType(self):
        return self.elementType
    def set_elementType(self, elementType):
        self.elementType = elementType
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_contactPoint(self):
        return self.contactPoint
    def set_contactPoint(self, contactPoint):
        self.contactPoint = contactPoint
    def get_elementS(self):
        return self.elementS
    def set_elementS(self, elementS):
        self.elementS = elementS
    def get_elementDir(self):
        return self.elementDir
    def set_elementDir(self, elementDir):
        self.elementDir = elementDir
    def validate_e_road_link_elementType(self, value):
        # Validate type e_road_link_elementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['road', 'junction']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_link_elementType' % {"value" : value.encode("utf-8")} )
    def validate_e_contactPoint(self, value):
        # Validate type e_contactPoint, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['start', 'end']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_contactPoint' % {"value" : value.encode("utf-8")} )
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_elementDir' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link_predecessorSuccessor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_link_predecessorSuccessor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link_predecessorSuccessor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_link_predecessorSuccessor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_link_predecessorSuccessor'):
        if 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
        if 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.contactPoint is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
        if self.elementS is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            outfile.write(' elementS="%s"' % self.gds_format_double(self.elementS, input_name='elementS'))
        if self.elementDir is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            outfile.write(' elementDir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementDir), input_name='elementDir')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link_predecessorSuccessor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
            self.validate_e_road_link_elementType(self.elementType)    # validate type e_road_link_elementType
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_e_contactPoint(self.contactPoint)    # validate type e_contactPoint
        value = find_attr_value_('elementS', node)
        if value is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            try:
                self.elementS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (elementS): %s' % exp)
            self.validate_t_grEqZero(self.elementS)    # validate type t_grEqZero
        value = find_attr_value_('elementDir', node)
        if value is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            self.elementDir = value
            self.validate_e_elementDir(self.elementDir)    # validate type e_elementDir
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_link_predecessorSuccessor


class t_road_link_neighbor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, side=None, elementId=None, direction=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_link_neighbor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_link_neighbor.subclass:
            return t_road_link_neighbor.subclass(*args_, **kwargs_)
        else:
            return t_road_link_neighbor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def validate_e_road_link_neighbor_side(self, value):
        # Validate type e_road_link_neighbor_side, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['left', 'right']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_link_neighbor_side' % {"value" : value.encode("utf-8")} )
    def validate_e_direction(self, value):
        # Validate type e_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['same', 'opposite']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link_neighbor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_link_neighbor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link_neighbor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_link_neighbor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_link_neighbor'):
        if 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link_neighbor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_e_road_link_neighbor_side(self.side)    # validate type e_road_link_neighbor_side
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.validate_e_direction(self.direction)    # validate type e_direction
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_link_neighbor


class t_road_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, type_=None, country=None, speed=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.country = _cast(None, country)
        self.country_nsprefix_ = None
        self.speed = speed
        self.speed_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_type.subclass:
            return t_road_type.subclass(*args_, **kwargs_)
        else:
            return t_road_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_roadType(self, value):
        # Validate type e_roadType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['unknown', 'rural', 'motorway', 'town', 'lowSpeed', 'pedestrian', 'bicycle', 'townExpressway', 'townCollector', 'townArterial', 'townPrivate', 'townLocal', 'townPlayStreet']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadType' % {"value" : value.encode("utf-8")} )
    def validate_e_countryCode(self, value):
        # Validate type e_countryCode, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.speed is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_type'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (quote_attrib(self.country), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.speed is not None:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            self.speed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_roadType(self.type_)    # validate type e_roadType
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
            self.validate_e_countryCode(self.country)    # validate type e_countryCode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'speed':
            obj_ = t_road_type_speed.factory(parent_object_=self)
            obj_.build(child_)
            self.speed = obj_
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_type


class t_road_type_speed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max=None, unit=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.max = _cast(None, max)
        self.max_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_type_speed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_type_speed.subclass:
            return t_road_type_speed.subclass(*args_, **kwargs_)
        else:
            return t_road_type_speed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def validate_t_maxSpeed(self, value):
        # Validate type t_maxSpeed, a restriction on None.
        pass
    def validate_e_unitSpeed(self, value):
        # Validate type e_unitSpeed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['m/s', 'mph', 'km/h']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_unitSpeed' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type_speed', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_type_speed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_type_speed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_type_speed', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_type_speed'):
        if 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max=%s' % (quote_attrib(self.max), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type_speed', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            self.max = value
            self.validate_t_maxSpeed(self.max)    # validate type t_maxSpeed
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_e_unitSpeed(self.unit)    # validate type e_unitSpeed
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_type_speed


class t_road_planView(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, geometry=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if geometry is None:
            self.geometry = []
        else:
            self.geometry = geometry
        self.geometry_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView.subclass:
            return t_road_planView.subclass(*args_, **kwargs_)
        else:
            return t_road_planView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_geometry(self):
        return self.geometry
    def set_geometry(self, geometry):
        self.geometry = geometry
    def add_geometry(self, value):
        self.geometry.append(value)
    def insert_geometry_at(self, index, value):
        self.geometry.insert(index, value)
    def replace_geometry_at(self, index, value):
        self.geometry[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.geometry or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for geometry_ in self.geometry:
            namespaceprefix_ = self.geometry_nsprefix_ + ':' if (UseCapturedNS_ and self.geometry_nsprefix_) else ''
            geometry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geometry', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geometry':
            obj_ = t_road_planView_geometry.factory(parent_object_=self)
            obj_.build(child_)
            self.geometry.append(obj_)
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView


class t_road_planView_geometry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, x=None, y=None, hdg=None, length=None, line=None, spiral=None, arc=None, poly3=None, paramPoly3=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.line = line
        self.line_nsprefix_ = None
        self.spiral = spiral
        self.spiral_nsprefix_ = None
        self.arc = arc
        self.arc_nsprefix_ = None
        self.poly3 = poly3
        self.poly3_nsprefix_ = None
        self.paramPoly3 = paramPoly3
        self.paramPoly3_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry.subclass:
            return t_road_planView_geometry.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_spiral(self):
        return self.spiral
    def set_spiral(self, spiral):
        self.spiral = spiral
    def get_arc(self):
        return self.arc
    def set_arc(self, arc):
        self.arc = arc
    def get_poly3(self):
        return self.poly3
    def set_poly3(self, poly3):
        self.poly3 = poly3
    def get_paramPoly3(self):
        return self.paramPoly3
    def set_paramPoly3(self, paramPoly3):
        self.paramPoly3 = paramPoly3
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_hdg(self):
        return self.hdg
    def set_hdg(self, hdg):
        self.hdg = hdg
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.line is not None or
            self.spiral is not None or
            self.arc is not None or
            self.poly3 is not None or
            self.paramPoly3 is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.line is not None:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            self.line.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        if self.spiral is not None:
            namespaceprefix_ = self.spiral_nsprefix_ + ':' if (UseCapturedNS_ and self.spiral_nsprefix_) else ''
            self.spiral.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spiral', pretty_print=pretty_print)
        if self.arc is not None:
            namespaceprefix_ = self.arc_nsprefix_ + ':' if (UseCapturedNS_ and self.arc_nsprefix_) else ''
            self.arc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arc', pretty_print=pretty_print)
        if self.poly3 is not None:
            namespaceprefix_ = self.poly3_nsprefix_ + ':' if (UseCapturedNS_ and self.poly3_nsprefix_) else ''
            self.poly3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='poly3', pretty_print=pretty_print)
        if self.paramPoly3 is not None:
            namespaceprefix_ = self.paramPoly3_nsprefix_ + ':' if (UseCapturedNS_ and self.paramPoly3_nsprefix_) else ''
            self.paramPoly3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paramPoly3', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            try:
                self.hdg = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hdg): %s' % exp)
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = t_road_planView_geometry_line.factory(parent_object_=self)
            obj_.build(child_)
            self.line = obj_
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'spiral':
            obj_ = t_road_planView_geometry_spiral.factory(parent_object_=self)
            obj_.build(child_)
            self.spiral = obj_
            obj_.original_tagname_ = 'spiral'
        elif nodeName_ == 'arc':
            obj_ = t_road_planView_geometry_arc.factory(parent_object_=self)
            obj_.build(child_)
            self.arc = obj_
            obj_.original_tagname_ = 'arc'
        elif nodeName_ == 'poly3':
            obj_ = t_road_planView_geometry_poly3.factory(parent_object_=self)
            obj_.build(child_)
            self.poly3 = obj_
            obj_.original_tagname_ = 'poly3'
        elif nodeName_ == 'paramPoly3':
            obj_ = t_road_planView_geometry_paramPoly3.factory(parent_object_=self)
            obj_.build(child_)
            self.paramPoly3 = obj_
            obj_.original_tagname_ = 'paramPoly3'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView_geometry


class t_road_planView_geometry_line(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_line.subclass:
            return t_road_planView_geometry_line.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_line')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_line', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_line'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_line', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView_geometry_line


class t_road_planView_geometry_spiral(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, curvStart=None, curvEnd=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.curvStart = _cast(float, curvStart)
        self.curvStart_nsprefix_ = None
        self.curvEnd = _cast(float, curvEnd)
        self.curvEnd_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_spiral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_spiral.subclass:
            return t_road_planView_geometry_spiral.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_spiral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_curvStart(self):
        return self.curvStart
    def set_curvStart(self, curvStart):
        self.curvStart = curvStart
    def get_curvEnd(self):
        return self.curvEnd
    def set_curvEnd(self, curvEnd):
        self.curvEnd = curvEnd
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_spiral', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_spiral')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_spiral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_spiral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_spiral'):
        if 'curvStart' not in already_processed:
            already_processed.add('curvStart')
            outfile.write(' curvStart="%s"' % self.gds_format_double(self.curvStart, input_name='curvStart'))
        if 'curvEnd' not in already_processed:
            already_processed.add('curvEnd')
            outfile.write(' curvEnd="%s"' % self.gds_format_double(self.curvEnd, input_name='curvEnd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_spiral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curvStart', node)
        if value is not None and 'curvStart' not in already_processed:
            already_processed.add('curvStart')
            try:
                self.curvStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (curvStart): %s' % exp)
        value = find_attr_value_('curvEnd', node)
        if value is not None and 'curvEnd' not in already_processed:
            already_processed.add('curvEnd')
            try:
                self.curvEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (curvEnd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView_geometry_spiral


class t_road_planView_geometry_arc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, curvature=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.curvature = _cast(float, curvature)
        self.curvature_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_arc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_arc.subclass:
            return t_road_planView_geometry_arc.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_arc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_curvature(self):
        return self.curvature
    def set_curvature(self, curvature):
        self.curvature = curvature
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_arc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_arc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_arc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_arc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_arc'):
        if 'curvature' not in already_processed:
            already_processed.add('curvature')
            outfile.write(' curvature="%s"' % self.gds_format_double(self.curvature, input_name='curvature'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_arc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curvature', node)
        if value is not None and 'curvature' not in already_processed:
            already_processed.add('curvature')
            try:
                self.curvature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (curvature): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView_geometry_arc


class t_road_planView_geometry_poly3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_poly3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_poly3.subclass:
            return t_road_planView_geometry_poly3.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_poly3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_poly3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_poly3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_poly3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_poly3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_poly3'):
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_poly3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView_geometry_poly3


class t_road_planView_geometry_paramPoly3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, aU=None, bU=None, cU=None, dU=None, aV=None, bV=None, cV=None, dV=None, pRange=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.aU = _cast(float, aU)
        self.aU_nsprefix_ = None
        self.bU = _cast(float, bU)
        self.bU_nsprefix_ = None
        self.cU = _cast(float, cU)
        self.cU_nsprefix_ = None
        self.dU = _cast(float, dU)
        self.dU_nsprefix_ = None
        self.aV = _cast(float, aV)
        self.aV_nsprefix_ = None
        self.bV = _cast(float, bV)
        self.bV_nsprefix_ = None
        self.cV = _cast(float, cV)
        self.cV_nsprefix_ = None
        self.dV = _cast(float, dV)
        self.dV_nsprefix_ = None
        self.pRange = _cast(None, pRange)
        self.pRange_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_paramPoly3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_paramPoly3.subclass:
            return t_road_planView_geometry_paramPoly3.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_paramPoly3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_aU(self):
        return self.aU
    def set_aU(self, aU):
        self.aU = aU
    def get_bU(self):
        return self.bU
    def set_bU(self, bU):
        self.bU = bU
    def get_cU(self):
        return self.cU
    def set_cU(self, cU):
        self.cU = cU
    def get_dU(self):
        return self.dU
    def set_dU(self, dU):
        self.dU = dU
    def get_aV(self):
        return self.aV
    def set_aV(self, aV):
        self.aV = aV
    def get_bV(self):
        return self.bV
    def set_bV(self, bV):
        self.bV = bV
    def get_cV(self):
        return self.cV
    def set_cV(self, cV):
        self.cV = cV
    def get_dV(self):
        return self.dV
    def set_dV(self, dV):
        self.dV = dV
    def get_pRange(self):
        return self.pRange
    def set_pRange(self, pRange):
        self.pRange = pRange
    def validate_e_paramPoly3_pRange(self, value):
        # Validate type e_paramPoly3_pRange, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['arcLength', 'normalized']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_paramPoly3_pRange' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_paramPoly3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_paramPoly3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_paramPoly3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_paramPoly3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_paramPoly3'):
        if 'aU' not in already_processed:
            already_processed.add('aU')
            outfile.write(' aU="%s"' % self.gds_format_double(self.aU, input_name='aU'))
        if 'bU' not in already_processed:
            already_processed.add('bU')
            outfile.write(' bU="%s"' % self.gds_format_double(self.bU, input_name='bU'))
        if 'cU' not in already_processed:
            already_processed.add('cU')
            outfile.write(' cU="%s"' % self.gds_format_double(self.cU, input_name='cU'))
        if 'dU' not in already_processed:
            already_processed.add('dU')
            outfile.write(' dU="%s"' % self.gds_format_double(self.dU, input_name='dU'))
        if 'aV' not in already_processed:
            already_processed.add('aV')
            outfile.write(' aV="%s"' % self.gds_format_double(self.aV, input_name='aV'))
        if 'bV' not in already_processed:
            already_processed.add('bV')
            outfile.write(' bV="%s"' % self.gds_format_double(self.bV, input_name='bV'))
        if 'cV' not in already_processed:
            already_processed.add('cV')
            outfile.write(' cV="%s"' % self.gds_format_double(self.cV, input_name='cV'))
        if 'dV' not in already_processed:
            already_processed.add('dV')
            outfile.write(' dV="%s"' % self.gds_format_double(self.dV, input_name='dV'))
        if 'pRange' not in already_processed:
            already_processed.add('pRange')
            outfile.write(' pRange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pRange), input_name='pRange')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_paramPoly3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aU', node)
        if value is not None and 'aU' not in already_processed:
            already_processed.add('aU')
            try:
                self.aU = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aU): %s' % exp)
        value = find_attr_value_('bU', node)
        if value is not None and 'bU' not in already_processed:
            already_processed.add('bU')
            try:
                self.bU = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (bU): %s' % exp)
        value = find_attr_value_('cU', node)
        if value is not None and 'cU' not in already_processed:
            already_processed.add('cU')
            try:
                self.cU = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cU): %s' % exp)
        value = find_attr_value_('dU', node)
        if value is not None and 'dU' not in already_processed:
            already_processed.add('dU')
            try:
                self.dU = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dU): %s' % exp)
        value = find_attr_value_('aV', node)
        if value is not None and 'aV' not in already_processed:
            already_processed.add('aV')
            try:
                self.aV = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aV): %s' % exp)
        value = find_attr_value_('bV', node)
        if value is not None and 'bV' not in already_processed:
            already_processed.add('bV')
            try:
                self.bV = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (bV): %s' % exp)
        value = find_attr_value_('cV', node)
        if value is not None and 'cV' not in already_processed:
            already_processed.add('cV')
            try:
                self.cV = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cV): %s' % exp)
        value = find_attr_value_('dV', node)
        if value is not None and 'dV' not in already_processed:
            already_processed.add('dV')
            try:
                self.dV = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dV): %s' % exp)
        value = find_attr_value_('pRange', node)
        if value is not None and 'pRange' not in already_processed:
            already_processed.add('pRange')
            self.pRange = value
            self.validate_e_paramPoly3_pRange(self.pRange)    # validate type e_paramPoly3_pRange
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_planView_geometry_paramPoly3


class t_road_elevationProfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, elevation=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if elevation is None:
            self.elevation = []
        else:
            self.elevation = elevation
        self.elevation_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_elevationProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_elevationProfile.subclass:
            return t_road_elevationProfile.subclass(*args_, **kwargs_)
        else:
            return t_road_elevationProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_elevation(self):
        return self.elevation
    def set_elevation(self, elevation):
        self.elevation = elevation
    def add_elevation(self, value):
        self.elevation.append(value)
    def insert_elevation_at(self, index, value):
        self.elevation.insert(index, value)
    def replace_elevation_at(self, index, value):
        self.elevation[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.elevation or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_elevationProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_elevationProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_elevationProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_elevationProfile'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for elevation_ in self.elevation:
            namespaceprefix_ = self.elevation_nsprefix_ + ':' if (UseCapturedNS_ and self.elevation_nsprefix_) else ''
            elevation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elevation', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'elevation':
            obj_ = t_road_elevationProfile_elevation.factory(parent_object_=self)
            obj_.build(child_)
            self.elevation.append(obj_)
            obj_.original_tagname_ = 'elevation'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_elevationProfile


class t_road_elevationProfile_elevation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_elevationProfile_elevation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_elevationProfile_elevation.subclass:
            return t_road_elevationProfile_elevation.subclass(*args_, **kwargs_)
        else:
            return t_road_elevationProfile_elevation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile_elevation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_elevationProfile_elevation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_elevationProfile_elevation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_elevationProfile_elevation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_elevationProfile_elevation'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile_elevation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_elevationProfile_elevation


class t_road_lateralProfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, superelevation=None, crossfall=None, shape=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if superelevation is None:
            self.superelevation = []
        else:
            self.superelevation = superelevation
        self.superelevation_nsprefix_ = None
        if crossfall is None:
            self.crossfall = []
        else:
            self.crossfall = crossfall
        self.crossfall_nsprefix_ = None
        if shape is None:
            self.shape = []
        else:
            self.shape = shape
        self.shape_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile.subclass:
            return t_road_lateralProfile.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_superelevation(self):
        return self.superelevation
    def set_superelevation(self, superelevation):
        self.superelevation = superelevation
    def add_superelevation(self, value):
        self.superelevation.append(value)
    def insert_superelevation_at(self, index, value):
        self.superelevation.insert(index, value)
    def replace_superelevation_at(self, index, value):
        self.superelevation[index] = value
    def get_crossfall(self):
        return self.crossfall
    def set_crossfall(self, crossfall):
        self.crossfall = crossfall
    def add_crossfall(self, value):
        self.crossfall.append(value)
    def insert_crossfall_at(self, index, value):
        self.crossfall.insert(index, value)
    def replace_crossfall_at(self, index, value):
        self.crossfall[index] = value
    def get_shape(self):
        return self.shape
    def set_shape(self, shape):
        self.shape = shape
    def add_shape(self, value):
        self.shape.append(value)
    def insert_shape_at(self, index, value):
        self.shape.insert(index, value)
    def replace_shape_at(self, index, value):
        self.shape[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.superelevation or
            self.crossfall or
            self.shape or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for superelevation_ in self.superelevation:
            namespaceprefix_ = self.superelevation_nsprefix_ + ':' if (UseCapturedNS_ and self.superelevation_nsprefix_) else ''
            superelevation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superelevation', pretty_print=pretty_print)
        for crossfall_ in self.crossfall:
            namespaceprefix_ = self.crossfall_nsprefix_ + ':' if (UseCapturedNS_ and self.crossfall_nsprefix_) else ''
            crossfall_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='crossfall', pretty_print=pretty_print)
        for shape_ in self.shape:
            namespaceprefix_ = self.shape_nsprefix_ + ':' if (UseCapturedNS_ and self.shape_nsprefix_) else ''
            shape_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shape', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'superelevation':
            obj_ = t_road_lateralProfile_superelevation.factory(parent_object_=self)
            obj_.build(child_)
            self.superelevation.append(obj_)
            obj_.original_tagname_ = 'superelevation'
        elif nodeName_ == 'crossfall':
            obj_ = t_road_lateralProfile_crossfall.factory(parent_object_=self)
            obj_.build(child_)
            self.crossfall.append(obj_)
            obj_.original_tagname_ = 'crossfall'
        elif nodeName_ == 'shape':
            obj_ = t_road_lateralProfile_shape.factory(parent_object_=self)
            obj_.build(child_)
            self.shape.append(obj_)
            obj_.original_tagname_ = 'shape'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lateralProfile


class t_road_lateralProfile_superelevation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile_superelevation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile_superelevation.subclass:
            return t_road_lateralProfile_superelevation.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile_superelevation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_superelevation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile_superelevation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_superelevation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile_superelevation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile_superelevation'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_superelevation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lateralProfile_superelevation


class t_road_lateralProfile_crossfall(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, side=None, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile_crossfall)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile_crossfall.subclass:
            return t_road_lateralProfile_crossfall.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile_crossfall(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_e_road_lateralProfile_crossfall_side(self, value):
        # Validate type e_road_lateralProfile_crossfall_side, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['left', 'right', 'both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_lateralProfile_crossfall_side' % {"value" : value.encode("utf-8")} )
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_crossfall', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile_crossfall')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_crossfall')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile_crossfall', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile_crossfall'):
        if 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_crossfall', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_e_road_lateralProfile_crossfall_side(self.side)    # validate type e_road_lateralProfile_crossfall_side
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lateralProfile_crossfall


class t_road_lateralProfile_shape(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile_shape)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile_shape.subclass:
            return t_road_lateralProfile_shape.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile_shape(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_shape', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile_shape')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_shape')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile_shape', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile_shape'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_shape', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lateralProfile_shape


class t_road_lanes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, laneOffset=None, laneSection=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if laneOffset is None:
            self.laneOffset = []
        else:
            self.laneOffset = laneOffset
        self.laneOffset_nsprefix_ = None
        if laneSection is None:
            self.laneSection = []
        else:
            self.laneSection = laneSection
        self.laneSection_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes.subclass:
            return t_road_lanes.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_laneOffset(self):
        return self.laneOffset
    def set_laneOffset(self, laneOffset):
        self.laneOffset = laneOffset
    def add_laneOffset(self, value):
        self.laneOffset.append(value)
    def insert_laneOffset_at(self, index, value):
        self.laneOffset.insert(index, value)
    def replace_laneOffset_at(self, index, value):
        self.laneOffset[index] = value
    def get_laneSection(self):
        return self.laneSection
    def set_laneSection(self, laneSection):
        self.laneSection = laneSection
    def add_laneSection(self, value):
        self.laneSection.append(value)
    def insert_laneSection_at(self, index, value):
        self.laneSection.insert(index, value)
    def replace_laneSection_at(self, index, value):
        self.laneSection[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.laneOffset or
            self.laneSection or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for laneOffset_ in self.laneOffset:
            namespaceprefix_ = self.laneOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.laneOffset_nsprefix_) else ''
            laneOffset_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneOffset', pretty_print=pretty_print)
        for laneSection_ in self.laneSection:
            namespaceprefix_ = self.laneSection_nsprefix_ + ':' if (UseCapturedNS_ and self.laneSection_nsprefix_) else ''
            laneSection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneSection', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'laneOffset':
            obj_ = t_road_lanes_laneOffset.factory(parent_object_=self)
            obj_.build(child_)
            self.laneOffset.append(obj_)
            obj_.original_tagname_ = 'laneOffset'
        elif nodeName_ == 'laneSection':
            obj_ = t_road_lanes_laneSection.factory(parent_object_=self)
            obj_.build(child_)
            self.laneSection.append(obj_)
            obj_.original_tagname_ = 'laneSection'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes


class t_road_lanes_laneOffset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneOffset.subclass:
            return t_road_lanes_laneOffset.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneOffset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneOffset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneOffset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneOffset'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneOffset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneOffset


class t_road_lanes_laneSection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, singleSide=None, left=None, center=None, right=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.singleSide = _cast(None, singleSide)
        self.singleSide_nsprefix_ = None
        self.left = left
        self.left_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.right = right
        self.right_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection.subclass:
            return t_road_lanes_laneSection.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_singleSide(self):
        return self.singleSide
    def set_singleSide(self, singleSide):
        self.singleSide = singleSide
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['true', 'false']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_bool' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.left is not None or
            self.center is not None or
            self.right is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.singleSide is not None and 'singleSide' not in already_processed:
            already_processed.add('singleSide')
            outfile.write(' singleSide=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.singleSide), input_name='singleSide')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_, namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_, namespacedef_='', name_='right', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('singleSide', node)
        if value is not None and 'singleSide' not in already_processed:
            already_processed.add('singleSide')
            self.singleSide = value
            self.validate_t_bool(self.singleSide)    # validate type t_bool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'left':
            obj_ = t_road_lanes_laneSection_left.factory(parent_object_=self)
            obj_.build(child_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'center':
            obj_ = t_road_lanes_laneSection_center.factory(parent_object_=self)
            obj_.build(child_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'right':
            obj_ = t_road_lanes_laneSection_right.factory(parent_object_=self)
            obj_.build(child_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection


class t_road_lanes_laneSection_left(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lane=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_left)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_left.subclass:
            return t_road_lanes_laneSection_left.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_left(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lane(self):
        return self.lane
    def set_lane(self, lane):
        self.lane = lane
    def add_lane(self, value):
        self.lane.append(value)
    def insert_lane_at(self, index, value):
        self.lane.insert(index, value)
    def replace_lane_at(self, index, value):
        self.lane[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.lane or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_left')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_left', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_left'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lane':
            obj_ = t_road_lanes_laneSection_left_lane.factory(parent_object_=self)
            obj_.build(child_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_left


class t_road_lanes_laneSection_center(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lane=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_center)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_center.subclass:
            return t_road_lanes_laneSection_center.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_center(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lane(self):
        return self.lane
    def set_lane(self, lane):
        self.lane = lane
    def add_lane(self, value):
        self.lane.append(value)
    def insert_lane_at(self, index, value):
        self.lane.insert(index, value)
    def replace_lane_at(self, index, value):
        self.lane[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.lane or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_center')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_center')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_center', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_center'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lane':
            obj_ = t_road_lanes_laneSection_center_lane.factory(parent_object_=self)
            obj_.build(child_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_center


class t_road_lanes_laneSection_right(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lane=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_right)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_right.subclass:
            return t_road_lanes_laneSection_right.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_right(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lane(self):
        return self.lane
    def set_lane(self, lane):
        self.lane = lane
    def add_lane(self, value):
        self.lane.append(value)
    def insert_lane_at(self, index, value):
        self.lane.insert(index, value)
    def replace_lane_at(self, index, value):
        self.lane[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.lane or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_right')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_right', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_right'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lane':
            obj_ = t_road_lanes_laneSection_right_lane.factory(parent_object_=self)
            obj_.build(child_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_right


class t_road_lanes_laneSection_center_lane(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=0, type_=None, level=None, link=None, roadMark=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if roadMark is None:
            self.roadMark = []
        else:
            self.roadMark = roadMark
        self.roadMark_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_center_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_center_lane.subclass:
            return t_road_lanes_laneSection_center_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_center_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_roadMark(self):
        return self.roadMark
    def set_roadMark(self, roadMark):
        self.roadMark = roadMark
    def add_roadMark(self, value):
        self.roadMark.append(value)
    def insert_roadMark_at(self, index, value):
        self.roadMark.insert(index, value)
    def replace_roadMark_at(self, index, value):
        self.roadMark[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def validate_e_laneType(self, value):
        # Validate type e_laneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'driving', 'stop', 'shoulder', 'biking', 'sidewalk', 'border', 'restricted', 'parking', 'bidirectional', 'median', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'entry', 'exit', 'offRamp', 'onRamp', 'connectingRamp', 'bus', 'taxi', 'HOV', 'mwyEntry', 'mwyExit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_laneType' % {"value" : value.encode("utf-8")} )
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['true', 'false']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_bool' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.link is not None or
            self.roadMark or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_center_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_center_lane')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_center_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_center_lane'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center_lane', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for roadMark_ in self.roadMark:
            namespaceprefix_ = self.roadMark_nsprefix_ + ':' if (UseCapturedNS_ and self.roadMark_nsprefix_) else ''
            roadMark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roadMark', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_laneType(self.type_)    # validate type e_laneType
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_t_bool(self.level)    # validate type t_bool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'link':
            obj_ = t_road_lanes_laneSection_lcr_lane_link.factory(parent_object_=self)
            obj_.build(child_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'roadMark':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark.factory(parent_object_=self)
            obj_.build(child_)
            self.roadMark.append(obj_)
            obj_.original_tagname_ = 'roadMark'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_center_lane


class t_road_lanes_laneSection_lr_lane(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, level=None, link=None, width=None, border=None, roadMark=None, material=None, visibility=None, speed=None, access=None, height=None, rule=None, userData=None, include=None, dataQuality=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if width is None:
            self.width = []
        else:
            self.width = width
        self.width_nsprefix_ = None
        if border is None:
            self.border = []
        else:
            self.border = border
        self.border_nsprefix_ = None
        if roadMark is None:
            self.roadMark = []
        else:
            self.roadMark = roadMark
        self.roadMark_nsprefix_ = None
        if material is None:
            self.material = []
        else:
            self.material = material
        self.material_nsprefix_ = None
        if visibility is None:
            self.visibility = []
        else:
            self.visibility = visibility
        self.visibility_nsprefix_ = None
        if speed is None:
            self.speed = []
        else:
            self.speed = speed
        self.speed_nsprefix_ = None
        if access is None:
            self.access = []
        else:
            self.access = access
        self.access_nsprefix_ = None
        if height is None:
            self.height = []
        else:
            self.height = height
        self.height_nsprefix_ = None
        if rule is None:
            self.rule = []
        else:
            self.rule = rule
        self.rule_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane.subclass:
            return t_road_lanes_laneSection_lr_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def add_width(self, value):
        self.width.append(value)
    def insert_width_at(self, index, value):
        self.width.insert(index, value)
    def replace_width_at(self, index, value):
        self.width[index] = value
    def get_border(self):
        return self.border
    def set_border(self, border):
        self.border = border
    def add_border(self, value):
        self.border.append(value)
    def insert_border_at(self, index, value):
        self.border.insert(index, value)
    def replace_border_at(self, index, value):
        self.border[index] = value
    def get_roadMark(self):
        return self.roadMark
    def set_roadMark(self, roadMark):
        self.roadMark = roadMark
    def add_roadMark(self, value):
        self.roadMark.append(value)
    def insert_roadMark_at(self, index, value):
        self.roadMark.insert(index, value)
    def replace_roadMark_at(self, index, value):
        self.roadMark[index] = value
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def add_material(self, value):
        self.material.append(value)
    def insert_material_at(self, index, value):
        self.material.insert(index, value)
    def replace_material_at(self, index, value):
        self.material[index] = value
    def get_visibility(self):
        return self.visibility
    def set_visibility(self, visibility):
        self.visibility = visibility
    def add_visibility(self, value):
        self.visibility.append(value)
    def insert_visibility_at(self, index, value):
        self.visibility.insert(index, value)
    def replace_visibility_at(self, index, value):
        self.visibility[index] = value
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    def add_speed(self, value):
        self.speed.append(value)
    def insert_speed_at(self, index, value):
        self.speed.insert(index, value)
    def replace_speed_at(self, index, value):
        self.speed[index] = value
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def add_access(self, value):
        self.access.append(value)
    def insert_access_at(self, index, value):
        self.access.insert(index, value)
    def replace_access_at(self, index, value):
        self.access[index] = value
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def add_height(self, value):
        self.height.append(value)
    def insert_height_at(self, index, value):
        self.height.insert(index, value)
    def replace_height_at(self, index, value):
        self.height[index] = value
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def add_rule(self, value):
        self.rule.append(value)
    def insert_rule_at(self, index, value):
        self.rule.insert(index, value)
    def replace_rule_at(self, index, value):
        self.rule[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_e_laneType(self, value):
        # Validate type e_laneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'driving', 'stop', 'shoulder', 'biking', 'sidewalk', 'border', 'restricted', 'parking', 'bidirectional', 'median', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'entry', 'exit', 'offRamp', 'onRamp', 'connectingRamp', 'bus', 'taxi', 'HOV', 'mwyEntry', 'mwyExit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_laneType' % {"value" : value.encode("utf-8")} )
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['true', 'false']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_bool' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.link is not None or
            self.width or
            self.border or
            self.roadMark or
            self.material or
            self.visibility or
            self.speed or
            self.access or
            self.height or
            self.rule or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane'):
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for width_ in self.width:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            width_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        for border_ in self.border:
            namespaceprefix_ = self.border_nsprefix_ + ':' if (UseCapturedNS_ and self.border_nsprefix_) else ''
            border_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='border', pretty_print=pretty_print)
        for roadMark_ in self.roadMark:
            namespaceprefix_ = self.roadMark_nsprefix_ + ':' if (UseCapturedNS_ and self.roadMark_nsprefix_) else ''
            roadMark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roadMark', pretty_print=pretty_print)
        for material_ in self.material:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            material_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
        for visibility_ in self.visibility:
            namespaceprefix_ = self.visibility_nsprefix_ + ':' if (UseCapturedNS_ and self.visibility_nsprefix_) else ''
            visibility_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='visibility', pretty_print=pretty_print)
        for speed_ in self.speed:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            speed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        for access_ in self.access:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            access_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        for height_ in self.height:
            namespaceprefix_ = self.height_nsprefix_ + ':' if (UseCapturedNS_ and self.height_nsprefix_) else ''
            height_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='height', pretty_print=pretty_print)
        for rule_ in self.rule:
            namespaceprefix_ = self.rule_nsprefix_ + ':' if (UseCapturedNS_ and self.rule_nsprefix_) else ''
            rule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rule', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_laneType(self.type_)    # validate type e_laneType
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_t_bool(self.level)    # validate type t_bool
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'link':
            obj_ = t_road_lanes_laneSection_lcr_lane_link.factory(parent_object_=self)
            obj_.build(child_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'width':
            obj_ = t_road_lanes_laneSection_lr_lane_width.factory(parent_object_=self)
            obj_.build(child_)
            self.width.append(obj_)
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'border':
            obj_ = t_road_lanes_laneSection_lr_lane_border.factory(parent_object_=self)
            obj_.build(child_)
            self.border.append(obj_)
            obj_.original_tagname_ = 'border'
        elif nodeName_ == 'roadMark':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark.factory(parent_object_=self)
            obj_.build(child_)
            self.roadMark.append(obj_)
            obj_.original_tagname_ = 'roadMark'
        elif nodeName_ == 'material':
            obj_ = t_road_lanes_laneSection_lr_lane_material.factory(parent_object_=self)
            obj_.build(child_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'visibility':
            obj_ = t_road_lanes_laneSection_lr_lane_visibility.factory(parent_object_=self)
            obj_.build(child_)
            self.visibility.append(obj_)
            obj_.original_tagname_ = 'visibility'
        elif nodeName_ == 'speed':
            obj_ = t_road_lanes_laneSection_lr_lane_speed.factory(parent_object_=self)
            obj_.build(child_)
            self.speed.append(obj_)
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'access':
            obj_ = t_road_lanes_laneSection_lr_lane_access.factory(parent_object_=self)
            obj_.build(child_)
            self.access.append(obj_)
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'height':
            obj_ = t_road_lanes_laneSection_lr_lane_height.factory(parent_object_=self)
            obj_.build(child_)
            self.height.append(obj_)
            obj_.original_tagname_ = 'height'
        elif nodeName_ == 'rule':
            obj_ = t_road_lanes_laneSection_lr_lane_rule.factory(parent_object_=self)
            obj_.build(child_)
            self.rule.append(obj_)
            obj_.original_tagname_ = 'rule'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane


class t_road_lanes_laneSection_left_lane(t_road_lanes_laneSection_lr_lane):
    subclass = None
    superclass = t_road_lanes_laneSection_lr_lane
    def __init__(self, type_=None, level=None, link=None, width=None, border=None, roadMark=None, material=None, visibility=None, speed=None, access=None, height=None, rule=None, userData=None, include=None, dataQuality=None, id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(t_road_lanes_laneSection_left_lane, self).__init__(type_, level, link, width, border, roadMark, material, visibility, speed, access, height, rule, userData, include, dataQuality,  **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_left_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_left_lane.subclass:
            return t_road_lanes_laneSection_left_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_left_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            super(t_road_lanes_laneSection_left_lane, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_left_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left_lane')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_left_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_left_lane'):
        super(t_road_lanes_laneSection_left_lane, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left_lane')
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left_lane', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_left_lane, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(t_road_lanes_laneSection_left_lane, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(t_road_lanes_laneSection_left_lane, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_left_lane


class t_road_lanes_laneSection_right_lane(t_road_lanes_laneSection_lr_lane):
    subclass = None
    superclass = t_road_lanes_laneSection_lr_lane
    def __init__(self, type_=None, level=None, link=None, width=None, border=None, roadMark=None, material=None, visibility=None, speed=None, access=None, height=None, rule=None, userData=None, include=None, dataQuality=None, id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(t_road_lanes_laneSection_right_lane, self).__init__(type_, level, link, width, border, roadMark, material, visibility, speed, access, height, rule, userData, include, dataQuality,  **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_right_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_right_lane.subclass:
            return t_road_lanes_laneSection_right_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_right_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            super(t_road_lanes_laneSection_right_lane, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_right_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right_lane')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_right_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_right_lane'):
        super(t_road_lanes_laneSection_right_lane, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right_lane')
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right_lane', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_right_lane, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id >= 0:
                raise_parse_error(node, 'Invalid NegativeInteger')
        super(t_road_lanes_laneSection_right_lane, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(t_road_lanes_laneSection_right_lane, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_right_lane


class t_road_lanes_laneSection_lcr_lane_link(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, predecessor=None, successor=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if predecessor is None:
            self.predecessor = []
        else:
            self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        if successor is None:
            self.successor = []
        else:
            self.successor = successor
        self.successor_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_link.subclass:
            return t_road_lanes_laneSection_lcr_lane_link.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predecessor(self):
        return self.predecessor
    def set_predecessor(self, predecessor):
        self.predecessor = predecessor
    def add_predecessor(self, value):
        self.predecessor.append(value)
    def insert_predecessor_at(self, index, value):
        self.predecessor.insert(index, value)
    def replace_predecessor_at(self, index, value):
        self.predecessor[index] = value
    def get_successor(self):
        return self.successor
    def set_successor(self, successor):
        self.successor = successor
    def add_successor(self, value):
        self.successor.append(value)
    def insert_successor_at(self, index, value):
        self.successor.insert(index, value)
    def replace_successor_at(self, index, value):
        self.successor[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.predecessor or
            self.successor or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_link'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for predecessor_ in self.predecessor:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            predecessor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        for successor_ in self.successor:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            successor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'predecessor':
            obj_ = t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_)
            self.predecessor.append(obj_)
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_)
            self.successor.append(obj_)
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_link


class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.subclass:
            return t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor


class t_road_lanes_laneSection_lr_lane_width(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_width)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_width.subclass:
            return t_road_lanes_laneSection_lr_lane_width.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_width(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_width', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_width')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_width')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_width', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_width'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_width', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_width


class t_road_lanes_laneSection_lr_lane_border(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_border)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_border.subclass:
            return t_road_lanes_laneSection_lr_lane_border.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_border(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_border', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_border')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_border')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_border', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_border'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_border', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_border


class t_road_lanes_laneSection_lcr_lane_roadMark(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, type__attr=None, weight=None, color=None, material=None, width=None, laneChange=None, height=None, sway=None, type_=None, explicit=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.type__attr = _cast(None, type__attr)
        self.type__attr_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.material = _cast(None, material)
        self.material_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.laneChange = _cast(None, laneChange)
        self.laneChange_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        if sway is None:
            self.sway = []
        else:
            self.sway = sway
        self.sway_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.explicit = explicit
        self.explicit_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sway(self):
        return self.sway
    def set_sway(self, sway):
        self.sway = sway
    def add_sway(self, value):
        self.sway.append(value)
    def insert_sway_at(self, index, value):
        self.sway.insert(index, value)
    def replace_sway_at(self, index, value):
        self.sway[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_explicit(self):
        return self.explicit
    def set_explicit(self, explicit):
        self.explicit = explicit
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_type__attr(self):
        return self.type__attr
    def set_type__attr(self, type__attr):
        self.type__attr = type__attr
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_laneChange(self):
        return self.laneChange
    def set_laneChange(self, laneChange):
        self.laneChange = laneChange
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_roadMarkWeight(self, value):
        # Validate type e_roadMarkWeight, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['standard', 'bold']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkWeight' % {"value" : value.encode("utf-8")} )
    def validate_e_roadMarkColor(self, value):
        # Validate type e_roadMarkColor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow', 'orange']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkColor' % {"value" : value.encode("utf-8")} )
    def validate_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange(self, value):
        # Validate type e_road_lanes_laneSection_lcr_lane_roadMark_laneChange, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['increase', 'decrease', 'both', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_lanes_laneSection_lcr_lane_roadMark_laneChange' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.sway or
            self.type_ is not None or
            self.explicit is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.type__attr is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type__attr), input_name='type__attr')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weight), input_name='weight')), ))
        if 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.material is not None and 'material' not in already_processed:
            already_processed.add('material')
            outfile.write(' material=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.material), input_name='material')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.laneChange is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            outfile.write(' laneChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.laneChange), input_name='laneChange')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sway_ in self.sway:
            namespaceprefix_ = self.sway_nsprefix_ + ':' if (UseCapturedNS_ and self.sway_nsprefix_) else ''
            sway_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sway', pretty_print=pretty_print)
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.explicit is not None:
            namespaceprefix_ = self.explicit_nsprefix_ + ':' if (UseCapturedNS_ and self.explicit_nsprefix_) else ''
            self.explicit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='explicit', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            self.type__attr = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_e_roadMarkWeight(self.weight)    # validate type e_roadMarkWeight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_e_roadMarkColor(self.color)    # validate type e_roadMarkColor
        value = find_attr_value_('material', node)
        if value is not None and 'material' not in already_processed:
            already_processed.add('material')
            self.material = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        value = find_attr_value_('laneChange', node)
        if value is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            self.laneChange = value
            self.validate_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange(self.laneChange)    # validate type e_road_lanes_laneSection_lcr_lane_roadMark_laneChange
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sway':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_sway.factory(parent_object_=self)
            obj_.build(child_)
            self.sway.append(obj_)
            obj_.original_tagname_ = 'sway'
        elif nodeName_ == 'type':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_type.factory(parent_object_=self)
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'explicit':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_explicit.factory(parent_object_=self)
            obj_.build(child_)
            self.explicit = obj_
            obj_.original_tagname_ = 'explicit'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_roadMark


class t_road_lanes_laneSection_lcr_lane_roadMark_sway(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ds=None, a=None, b=None, c=None, d=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ds = _cast(float, ds)
        self.ds_nsprefix_ = None
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_sway)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_sway.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_sway.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_sway(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_ds(self):
        return self.ds
    def set_ds(self, ds):
        self.ds = ds
    def get_a(self):
        return self.a
    def set_a(self, a):
        self.a = a
    def get_b(self):
        return self.b
    def set_b(self, b):
        self.b = b
    def get_c(self):
        return self.c
    def set_c(self, c):
        self.c = c
    def get_d(self):
        return self.d
    def set_d(self, d):
        self.d = d
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_sway')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway'):
        if 'ds' not in already_processed:
            already_processed.add('ds')
            outfile.write(' ds="%s"' % self.gds_format_double(self.ds, input_name='ds'))
        if 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ds', node)
        if value is not None and 'ds' not in already_processed:
            already_processed.add('ds')
            try:
                self.ds = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ds): %s' % exp)
            self.validate_t_grEqZero(self.ds)    # validate type t_grEqZero
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            try:
                self.c = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c): %s' % exp)
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_roadMark_sway


class t_road_lanes_laneSection_lcr_lane_roadMark_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, width=None, line=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_type.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.line or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type'):
        if 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_type_line.factory(parent_object_=self)
            obj_.build(child_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_roadMark_type


class t_road_lanes_laneSection_lcr_lane_roadMark_type_line(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, length=None, space=None, tOffset=None, sOffset=None, rule=None, width=None, color=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.space = _cast(float, space)
        self.space_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_type_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_type_line.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type_line.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_tOffset(self):
        return self.tOffset
    def set_tOffset(self, tOffset):
        self.tOffset = tOffset
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_roadMarkRule(self, value):
        # Validate type e_roadMarkRule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['no passing', 'caution', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkRule' % {"value" : value.encode("utf-8")} )
    def validate_e_roadMarkColor(self, value):
        # Validate type e_roadMarkColor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow', 'orange']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkColor' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_type_line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line'):
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space="%s"' % self.gds_format_double(self.space, input_name='space'))
        if 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            try:
                self.space = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (space): %s' % exp)
            self.validate_t_grEqZero(self.space)    # validate type t_grEqZero
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            try:
                self.tOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tOffset): %s' % exp)
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_roadMarkRule(self.rule)    # validate type e_roadMarkRule
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_e_roadMarkColor(self.color)    # validate type e_roadMarkColor
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_roadMark_type_line


class t_road_lanes_laneSection_lcr_lane_roadMark_explicit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, line=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_explicit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_explicit.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.line or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_explicit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line.factory(parent_object_=self)
            obj_.build(child_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_roadMark_explicit


class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, length=None, tOffset=None, sOffset=None, rule=None, width=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_tOffset(self):
        return self.tOffset
    def set_tOffset(self, tOffset):
        self.tOffset = tOffset
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_roadMarkRule(self, value):
        # Validate type e_roadMarkRule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['no passing', 'caution', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkRule' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line'):
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            try:
                self.tOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tOffset): %s' % exp)
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_roadMarkRule(self.rule)    # validate type e_roadMarkRule
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line


class t_road_lanes_laneSection_lr_lane_material(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, surface=None, friction=None, roughness=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
        self.friction = _cast(float, friction)
        self.friction_nsprefix_ = None
        self.roughness = _cast(float, roughness)
        self.roughness_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_material.subclass:
            return t_road_lanes_laneSection_lr_lane_material.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_friction(self):
        return self.friction
    def set_friction(self, friction):
        self.friction = friction
    def get_roughness(self):
        return self.roughness
    def set_roughness(self, roughness):
        self.roughness = roughness
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_material')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_material', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_material'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
        if 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
        if self.roughness is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            outfile.write(' roughness="%s"' % self.gds_format_double(self.roughness, input_name='roughness'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_material', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            try:
                self.friction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (friction): %s' % exp)
            self.validate_t_grEqZero(self.friction)    # validate type t_grEqZero
        value = find_attr_value_('roughness', node)
        if value is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            try:
                self.roughness = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roughness): %s' % exp)
            self.validate_t_grEqZero(self.roughness)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_material


class t_road_lanes_laneSection_lr_lane_visibility(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, forward=None, back=None, left=None, right=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.forward = _cast(float, forward)
        self.forward_nsprefix_ = None
        self.back = _cast(float, back)
        self.back_nsprefix_ = None
        self.left = _cast(float, left)
        self.left_nsprefix_ = None
        self.right = _cast(float, right)
        self.right_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_visibility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_visibility.subclass:
            return t_road_lanes_laneSection_lr_lane_visibility.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_visibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_forward(self):
        return self.forward
    def set_forward(self, forward):
        self.forward = forward
    def get_back(self):
        return self.back
    def set_back(self, back):
        self.back = back
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_visibility', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_visibility')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_visibility')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_visibility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_visibility'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'forward' not in already_processed:
            already_processed.add('forward')
            outfile.write(' forward="%s"' % self.gds_format_double(self.forward, input_name='forward'))
        if 'back' not in already_processed:
            already_processed.add('back')
            outfile.write(' back="%s"' % self.gds_format_double(self.back, input_name='back'))
        if 'left' not in already_processed:
            already_processed.add('left')
            outfile.write(' left="%s"' % self.gds_format_double(self.left, input_name='left'))
        if 'right' not in already_processed:
            already_processed.add('right')
            outfile.write(' right="%s"' % self.gds_format_double(self.right, input_name='right'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_visibility', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('forward', node)
        if value is not None and 'forward' not in already_processed:
            already_processed.add('forward')
            try:
                self.forward = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (forward): %s' % exp)
            self.validate_t_grEqZero(self.forward)    # validate type t_grEqZero
        value = find_attr_value_('back', node)
        if value is not None and 'back' not in already_processed:
            already_processed.add('back')
            try:
                self.back = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (back): %s' % exp)
            self.validate_t_grEqZero(self.back)    # validate type t_grEqZero
        value = find_attr_value_('left', node)
        if value is not None and 'left' not in already_processed:
            already_processed.add('left')
            try:
                self.left = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (left): %s' % exp)
            self.validate_t_grEqZero(self.left)    # validate type t_grEqZero
        value = find_attr_value_('right', node)
        if value is not None and 'right' not in already_processed:
            already_processed.add('right')
            try:
                self.right = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (right): %s' % exp)
            self.validate_t_grEqZero(self.right)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_visibility


class t_road_lanes_laneSection_lr_lane_speed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, max=None, unit=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.max = _cast(float, max)
        self.max_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_speed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_speed.subclass:
            return t_road_lanes_laneSection_lr_lane_speed.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_speed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_unitSpeed(self, value):
        # Validate type e_unitSpeed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['m/s', 'mph', 'km/h']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_unitSpeed' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_speed', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_speed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_speed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_speed', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_speed'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_double(self.max, input_name='max'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_speed', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (max): %s' % exp)
            self.validate_t_grEqZero(self.max)    # validate type t_grEqZero
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_e_unitSpeed(self.unit)    # validate type e_unitSpeed
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_speed


class t_road_lanes_laneSection_lr_lane_access(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, rule=None, restriction=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.restriction = _cast(None, restriction)
        self.restriction_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_access)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_access.subclass:
            return t_road_lanes_laneSection_lr_lane_access.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_access(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_rule(self):
        return self.rule
    def set_rule(self, rule):
        self.rule = rule
    def get_restriction(self):
        return self.restriction
    def set_restriction(self, restriction):
        self.restriction = restriction
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_road_lanes_laneSection_lr_lane_access_rule(self, value):
        # Validate type e_road_lanes_laneSection_lr_lane_access_rule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['allow', 'deny']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_lanes_laneSection_lr_lane_access_rule' % {"value" : value.encode("utf-8")} )
    def validate_e_accessRestrictionType(self, value):
        # Validate type e_accessRestrictionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['simulator', 'autonomousTraffic', 'pedestrian', 'passengerCar', 'bus', 'delivery', 'emergency', 'taxi', 'throughTraffic', 'truck', 'bicycle', 'motorcycle', 'none', 'trucks']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_accessRestrictionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_access', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_access')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_access')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_access', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_access'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if 'restriction' not in already_processed:
            already_processed.add('restriction')
            outfile.write(' restriction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restriction), input_name='restriction')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_access', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_road_lanes_laneSection_lr_lane_access_rule(self.rule)    # validate type e_road_lanes_laneSection_lr_lane_access_rule
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.add('restriction')
            self.restriction = value
            self.validate_e_accessRestrictionType(self.restriction)    # validate type e_accessRestrictionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_access


class t_road_lanes_laneSection_lr_lane_height(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, inner=None, outer=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.inner = _cast(float, inner)
        self.inner_nsprefix_ = None
        self.outer = _cast(float, outer)
        self.outer_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_height)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_height.subclass:
            return t_road_lanes_laneSection_lr_lane_height.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_height(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_inner(self):
        return self.inner
    def set_inner(self, inner):
        self.inner = inner
    def get_outer(self):
        return self.outer
    def set_outer(self, outer):
        self.outer = outer
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_height', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_height')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_height')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_height', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_height'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'inner' not in already_processed:
            already_processed.add('inner')
            outfile.write(' inner="%s"' % self.gds_format_double(self.inner, input_name='inner'))
        if 'outer' not in already_processed:
            already_processed.add('outer')
            outfile.write(' outer="%s"' % self.gds_format_double(self.outer, input_name='outer'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_height', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('inner', node)
        if value is not None and 'inner' not in already_processed:
            already_processed.add('inner')
            try:
                self.inner = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (inner): %s' % exp)
        value = find_attr_value_('outer', node)
        if value is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            try:
                self.outer = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (outer): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_height


class t_road_lanes_laneSection_lr_lane_rule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sOffset=None, value=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_rule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_rule.subclass:
            return t_road_lanes_laneSection_lr_lane_rule.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_rule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_rule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_rule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_rule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_rule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_rule'):
        if 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_rule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_lanes_laneSection_lr_lane_rule


class t_road_objects(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object=None, objectReference=None, tunnel=None, bridge=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if object is None:
            self.object = []
        else:
            self.object = object
        self.object_nsprefix_ = None
        if objectReference is None:
            self.objectReference = []
        else:
            self.objectReference = objectReference
        self.objectReference_nsprefix_ = None
        if tunnel is None:
            self.tunnel = []
        else:
            self.tunnel = tunnel
        self.tunnel_nsprefix_ = None
        if bridge is None:
            self.bridge = []
        else:
            self.bridge = bridge
        self.bridge_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects.subclass:
            return t_road_objects.subclass(*args_, **kwargs_)
        else:
            return t_road_objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object(self):
        return self.object
    def set_object(self, object):
        self.object = object
    def add_object(self, value):
        self.object.append(value)
    def insert_object_at(self, index, value):
        self.object.insert(index, value)
    def replace_object_at(self, index, value):
        self.object[index] = value
    def get_objectReference(self):
        return self.objectReference
    def set_objectReference(self, objectReference):
        self.objectReference = objectReference
    def add_objectReference(self, value):
        self.objectReference.append(value)
    def insert_objectReference_at(self, index, value):
        self.objectReference.insert(index, value)
    def replace_objectReference_at(self, index, value):
        self.objectReference[index] = value
    def get_tunnel(self):
        return self.tunnel
    def set_tunnel(self, tunnel):
        self.tunnel = tunnel
    def add_tunnel(self, value):
        self.tunnel.append(value)
    def insert_tunnel_at(self, index, value):
        self.tunnel.insert(index, value)
    def replace_tunnel_at(self, index, value):
        self.tunnel[index] = value
    def get_bridge(self):
        return self.bridge
    def set_bridge(self, bridge):
        self.bridge = bridge
    def add_bridge(self, value):
        self.bridge.append(value)
    def insert_bridge_at(self, index, value):
        self.bridge.insert(index, value)
    def replace_bridge_at(self, index, value):
        self.bridge[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.object or
            self.objectReference or
            self.tunnel or
            self.bridge or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.object:
            namespaceprefix_ = self.object_nsprefix_ + ':' if (UseCapturedNS_ and self.object_nsprefix_) else ''
            object_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object', pretty_print=pretty_print)
        for objectReference_ in self.objectReference:
            namespaceprefix_ = self.objectReference_nsprefix_ + ':' if (UseCapturedNS_ and self.objectReference_nsprefix_) else ''
            objectReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objectReference', pretty_print=pretty_print)
        for tunnel_ in self.tunnel:
            namespaceprefix_ = self.tunnel_nsprefix_ + ':' if (UseCapturedNS_ and self.tunnel_nsprefix_) else ''
            tunnel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tunnel', pretty_print=pretty_print)
        for bridge_ in self.bridge:
            namespaceprefix_ = self.bridge_nsprefix_ + ':' if (UseCapturedNS_ and self.bridge_nsprefix_) else ''
            bridge_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bridge', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = t_road_objects_object.factory(parent_object_=self)
            obj_.build(child_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'objectReference':
            obj_ = t_road_objects_objectReference.factory(parent_object_=self)
            obj_.build(child_)
            self.objectReference.append(obj_)
            obj_.original_tagname_ = 'objectReference'
        elif nodeName_ == 'tunnel':
            obj_ = t_road_objects_tunnel.factory(parent_object_=self)
            obj_.build(child_)
            self.tunnel.append(obj_)
            obj_.original_tagname_ = 'tunnel'
        elif nodeName_ == 'bridge':
            obj_ = t_road_objects_bridge.factory(parent_object_=self)
            obj_.build(child_)
            self.bridge.append(obj_)
            obj_.original_tagname_ = 'bridge'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects


class t_road_objects_object(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, subtype=None, dynamic=None, name=None, id=None, s=None, t=None, zOffset=None, validLength=None, orientation=None, hdg=None, pitch=None, roll=None, height=None, length=None, width=None, radius=None, repeat=None, outline=None, outlines=None, material=None, validity=None, parkingSpace=None, markings=None, borders=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.subtype = _cast(None, subtype)
        self.subtype_nsprefix_ = None
        self.dynamic = _cast(None, dynamic)
        self.dynamic_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.validLength = _cast(float, validLength)
        self.validLength_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.radius = _cast(float, radius)
        self.radius_nsprefix_ = None
        self.repeat = repeat
        self.repeat_nsprefix_ = None
        self.outline = outline
        self.outline_nsprefix_ = None
        self.outlines = outlines
        self.outlines_nsprefix_ = None
        if material is None:
            self.material = []
        else:
            self.material = material
        self.material_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        self.parkingSpace = parkingSpace
        self.parkingSpace_nsprefix_ = None
        self.markings = markings
        self.markings_nsprefix_ = None
        self.borders = borders
        self.borders_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object.subclass:
            return t_road_objects_object.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_repeat(self):
        return self.repeat
    def set_repeat(self, repeat):
        self.repeat = repeat
    def get_outline(self):
        return self.outline
    def set_outline(self, outline):
        self.outline = outline
    def get_outlines(self):
        return self.outlines
    def set_outlines(self, outlines):
        self.outlines = outlines
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def add_material(self, value):
        self.material.append(value)
    def insert_material_at(self, index, value):
        self.material.insert(index, value)
    def replace_material_at(self, index, value):
        self.material[index] = value
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_parkingSpace(self):
        return self.parkingSpace
    def set_parkingSpace(self, parkingSpace):
        self.parkingSpace = parkingSpace
    def get_markings(self):
        return self.markings
    def set_markings(self, markings):
        self.markings = markings
    def get_borders(self):
        return self.borders
    def set_borders(self, borders):
        self.borders = borders
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_subtype(self):
        return self.subtype
    def set_subtype(self, subtype):
        self.subtype = subtype
    def get_dynamic(self):
        return self.dynamic
    def set_dynamic(self, dynamic):
        self.dynamic = dynamic
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_validLength(self):
        return self.validLength
    def set_validLength(self, validLength):
        self.validLength = validLength
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_hdg(self):
        return self.hdg
    def set_hdg(self, hdg):
        self.hdg = hdg
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_roll(self):
        return self.roll
    def set_roll(self, roll):
        self.roll = roll
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_radius(self):
        return self.radius
    def set_radius(self, radius):
        self.radius = radius
    def validate_e_objectType(self, value):
        # Validate type e_objectType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'obstacle', 'car', 'pole', 'tree', 'vegetation', 'barrier', 'building', 'parkingSpace', 'patch', 'railing', 'trafficIsland', 'crosswalk', 'streetLamp', 'gantry', 'soundBarrier', 'truck', 'van', 'bus', 'trailer', 'bike', 'motorbike', 'tram', 'train', 'pedestrian', 'wind']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_objectType' % {"value" : value.encode("utf-8")} )
    def validate_t_yesNo(self, value):
        # Validate type t_yesNo, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_yesNo' % {"value" : value.encode("utf-8")} )
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_orientation' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.repeat is not None or
            self.outline is not None or
            self.outlines is not None or
            self.material or
            self.validity or
            self.parkingSpace is not None or
            self.markings is not None or
            self.borders is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.subtype is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            outfile.write(' subtype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subtype), input_name='subtype')), ))
        if 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            outfile.write(' dynamic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dynamic), input_name='dynamic')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if 'validLength' not in already_processed:
            already_processed.add('validLength')
            outfile.write(' validLength="%s"' % self.gds_format_double(self.validLength, input_name='validLength'))
        if 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
        if 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.repeat is not None:
            namespaceprefix_ = self.repeat_nsprefix_ + ':' if (UseCapturedNS_ and self.repeat_nsprefix_) else ''
            self.repeat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeat', pretty_print=pretty_print)
        if self.outline is not None:
            namespaceprefix_ = self.outline_nsprefix_ + ':' if (UseCapturedNS_ and self.outline_nsprefix_) else ''
            self.outline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outline', pretty_print=pretty_print)
        if self.outlines is not None:
            namespaceprefix_ = self.outlines_nsprefix_ + ':' if (UseCapturedNS_ and self.outlines_nsprefix_) else ''
            self.outlines.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outlines', pretty_print=pretty_print)
        for material_ in self.material:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            material_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        if self.parkingSpace is not None:
            namespaceprefix_ = self.parkingSpace_nsprefix_ + ':' if (UseCapturedNS_ and self.parkingSpace_nsprefix_) else ''
            self.parkingSpace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parkingSpace', pretty_print=pretty_print)
        if self.markings is not None:
            namespaceprefix_ = self.markings_nsprefix_ + ':' if (UseCapturedNS_ and self.markings_nsprefix_) else ''
            self.markings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='markings', pretty_print=pretty_print)
        if self.borders is not None:
            namespaceprefix_ = self.borders_nsprefix_ + ':' if (UseCapturedNS_ and self.borders_nsprefix_) else ''
            self.borders.export(outfile, level, namespaceprefix_, namespacedef_='', name_='borders', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_objectType(self.type_)    # validate type e_objectType
        value = find_attr_value_('subtype', node)
        if value is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            self.subtype = value
        value = find_attr_value_('dynamic', node)
        if value is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            self.dynamic = value
            self.validate_t_yesNo(self.dynamic)    # validate type t_yesNo
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
        value = find_attr_value_('validLength', node)
        if value is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            try:
                self.validLength = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (validLength): %s' % exp)
            self.validate_t_grEqZero(self.validLength)    # validate type t_grEqZero
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            try:
                self.hdg = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hdg): %s' % exp)
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            try:
                self.pitch = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pitch): %s' % exp)
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            try:
                self.roll = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roll): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            try:
                self.radius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radius): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'repeat':
            obj_ = t_road_objects_object_repeat.factory(parent_object_=self)
            obj_.build(child_)
            self.repeat = obj_
            obj_.original_tagname_ = 'repeat'
        elif nodeName_ == 'outline':
            obj_ = t_road_objects_object_outlines_outline.factory(parent_object_=self)
            obj_.build(child_)
            self.outline = obj_
            obj_.original_tagname_ = 'outline'
        elif nodeName_ == 'outlines':
            obj_ = t_road_objects_object_outlines.factory(parent_object_=self)
            obj_.build(child_)
            self.outlines = obj_
            obj_.original_tagname_ = 'outlines'
        elif nodeName_ == 'material':
            obj_ = t_road_objects_object_material.factory(parent_object_=self)
            obj_.build(child_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'parkingSpace':
            obj_ = t_road_objects_object_parkingSpace.factory(parent_object_=self)
            obj_.build(child_)
            self.parkingSpace = obj_
            obj_.original_tagname_ = 'parkingSpace'
        elif nodeName_ == 'markings':
            obj_ = t_road_objects_object_markings.factory(parent_object_=self)
            obj_.build(child_)
            self.markings = obj_
            obj_.original_tagname_ = 'markings'
        elif nodeName_ == 'borders':
            obj_ = t_road_objects_object_borders.factory(parent_object_=self)
            obj_.build(child_)
            self.borders = obj_
            obj_.original_tagname_ = 'borders'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object


class t_road_objects_object_repeat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, length=None, distance=None, tStart=None, tEnd=None, heightStart=None, heightEnd=None, zOffsetStart=None, zOffsetEnd=None, widthStart=None, widthEnd=None, lengthStart=None, lengthEnd=None, radiusStart=None, radiusEnd=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.distance = _cast(float, distance)
        self.distance_nsprefix_ = None
        self.tStart = _cast(float, tStart)
        self.tStart_nsprefix_ = None
        self.tEnd = _cast(float, tEnd)
        self.tEnd_nsprefix_ = None
        self.heightStart = _cast(float, heightStart)
        self.heightStart_nsprefix_ = None
        self.heightEnd = _cast(float, heightEnd)
        self.heightEnd_nsprefix_ = None
        self.zOffsetStart = _cast(float, zOffsetStart)
        self.zOffsetStart_nsprefix_ = None
        self.zOffsetEnd = _cast(float, zOffsetEnd)
        self.zOffsetEnd_nsprefix_ = None
        self.widthStart = _cast(float, widthStart)
        self.widthStart_nsprefix_ = None
        self.widthEnd = _cast(float, widthEnd)
        self.widthEnd_nsprefix_ = None
        self.lengthStart = _cast(float, lengthStart)
        self.lengthStart_nsprefix_ = None
        self.lengthEnd = _cast(float, lengthEnd)
        self.lengthEnd_nsprefix_ = None
        self.radiusStart = _cast(float, radiusStart)
        self.radiusStart_nsprefix_ = None
        self.radiusEnd = _cast(float, radiusEnd)
        self.radiusEnd_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_repeat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_repeat.subclass:
            return t_road_objects_object_repeat.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_repeat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def get_tStart(self):
        return self.tStart
    def set_tStart(self, tStart):
        self.tStart = tStart
    def get_tEnd(self):
        return self.tEnd
    def set_tEnd(self, tEnd):
        self.tEnd = tEnd
    def get_heightStart(self):
        return self.heightStart
    def set_heightStart(self, heightStart):
        self.heightStart = heightStart
    def get_heightEnd(self):
        return self.heightEnd
    def set_heightEnd(self, heightEnd):
        self.heightEnd = heightEnd
    def get_zOffsetStart(self):
        return self.zOffsetStart
    def set_zOffsetStart(self, zOffsetStart):
        self.zOffsetStart = zOffsetStart
    def get_zOffsetEnd(self):
        return self.zOffsetEnd
    def set_zOffsetEnd(self, zOffsetEnd):
        self.zOffsetEnd = zOffsetEnd
    def get_widthStart(self):
        return self.widthStart
    def set_widthStart(self, widthStart):
        self.widthStart = widthStart
    def get_widthEnd(self):
        return self.widthEnd
    def set_widthEnd(self, widthEnd):
        self.widthEnd = widthEnd
    def get_lengthStart(self):
        return self.lengthStart
    def set_lengthStart(self, lengthStart):
        self.lengthStart = lengthStart
    def get_lengthEnd(self):
        return self.lengthEnd
    def set_lengthEnd(self, lengthEnd):
        self.lengthEnd = lengthEnd
    def get_radiusStart(self):
        return self.radiusStart
    def set_radiusStart(self, radiusStart):
        self.radiusStart = radiusStart
    def get_radiusEnd(self):
        return self.radiusEnd
    def set_radiusEnd(self, radiusEnd):
        self.radiusEnd = radiusEnd
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_repeat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_repeat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_repeat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_repeat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_repeat'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if 'distance' not in already_processed:
            already_processed.add('distance')
            outfile.write(' distance="%s"' % self.gds_format_double(self.distance, input_name='distance'))
        if 'tStart' not in already_processed:
            already_processed.add('tStart')
            outfile.write(' tStart="%s"' % self.gds_format_double(self.tStart, input_name='tStart'))
        if 'tEnd' not in already_processed:
            already_processed.add('tEnd')
            outfile.write(' tEnd="%s"' % self.gds_format_double(self.tEnd, input_name='tEnd'))
        if 'heightStart' not in already_processed:
            already_processed.add('heightStart')
            outfile.write(' heightStart="%s"' % self.gds_format_double(self.heightStart, input_name='heightStart'))
        if 'heightEnd' not in already_processed:
            already_processed.add('heightEnd')
            outfile.write(' heightEnd="%s"' % self.gds_format_double(self.heightEnd, input_name='heightEnd'))
        if 'zOffsetStart' not in already_processed:
            already_processed.add('zOffsetStart')
            outfile.write(' zOffsetStart="%s"' % self.gds_format_double(self.zOffsetStart, input_name='zOffsetStart'))
        if 'zOffsetEnd' not in already_processed:
            already_processed.add('zOffsetEnd')
            outfile.write(' zOffsetEnd="%s"' % self.gds_format_double(self.zOffsetEnd, input_name='zOffsetEnd'))
        if 'widthStart' not in already_processed:
            already_processed.add('widthStart')
            outfile.write(' widthStart="%s"' % self.gds_format_double(self.widthStart, input_name='widthStart'))
        if 'widthEnd' not in already_processed:
            already_processed.add('widthEnd')
            outfile.write(' widthEnd="%s"' % self.gds_format_double(self.widthEnd, input_name='widthEnd'))
        if self.lengthStart is not None and 'lengthStart' not in already_processed:
            already_processed.add('lengthStart')
            outfile.write(' lengthStart="%s"' % self.gds_format_double(self.lengthStart, input_name='lengthStart'))
        if self.lengthEnd is not None and 'lengthEnd' not in already_processed:
            already_processed.add('lengthEnd')
            outfile.write(' lengthEnd="%s"' % self.gds_format_double(self.lengthEnd, input_name='lengthEnd'))
        if self.radiusStart is not None and 'radiusStart' not in already_processed:
            already_processed.add('radiusStart')
            outfile.write(' radiusStart="%s"' % self.gds_format_double(self.radiusStart, input_name='radiusStart'))
        if self.radiusEnd is not None and 'radiusEnd' not in already_processed:
            already_processed.add('radiusEnd')
            outfile.write(' radiusEnd="%s"' % self.gds_format_double(self.radiusEnd, input_name='radiusEnd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_repeat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('distance', node)
        if value is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            try:
                self.distance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distance): %s' % exp)
            self.validate_t_grEqZero(self.distance)    # validate type t_grEqZero
        value = find_attr_value_('tStart', node)
        if value is not None and 'tStart' not in already_processed:
            already_processed.add('tStart')
            try:
                self.tStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tStart): %s' % exp)
        value = find_attr_value_('tEnd', node)
        if value is not None and 'tEnd' not in already_processed:
            already_processed.add('tEnd')
            try:
                self.tEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tEnd): %s' % exp)
        value = find_attr_value_('heightStart', node)
        if value is not None and 'heightStart' not in already_processed:
            already_processed.add('heightStart')
            try:
                self.heightStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heightStart): %s' % exp)
        value = find_attr_value_('heightEnd', node)
        if value is not None and 'heightEnd' not in already_processed:
            already_processed.add('heightEnd')
            try:
                self.heightEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heightEnd): %s' % exp)
        value = find_attr_value_('zOffsetStart', node)
        if value is not None and 'zOffsetStart' not in already_processed:
            already_processed.add('zOffsetStart')
            try:
                self.zOffsetStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffsetStart): %s' % exp)
        value = find_attr_value_('zOffsetEnd', node)
        if value is not None and 'zOffsetEnd' not in already_processed:
            already_processed.add('zOffsetEnd')
            try:
                self.zOffsetEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffsetEnd): %s' % exp)
        value = find_attr_value_('widthStart', node)
        if value is not None and 'widthStart' not in already_processed:
            already_processed.add('widthStart')
            try:
                self.widthStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (widthStart): %s' % exp)
            self.validate_t_grEqZero(self.widthStart)    # validate type t_grEqZero
        value = find_attr_value_('widthEnd', node)
        if value is not None and 'widthEnd' not in already_processed:
            already_processed.add('widthEnd')
            try:
                self.widthEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (widthEnd): %s' % exp)
            self.validate_t_grEqZero(self.widthEnd)    # validate type t_grEqZero
        value = find_attr_value_('lengthStart', node)
        if value is not None and 'lengthStart' not in already_processed:
            already_processed.add('lengthStart')
            try:
                self.lengthStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lengthStart): %s' % exp)
            self.validate_t_grEqZero(self.lengthStart)    # validate type t_grEqZero
        value = find_attr_value_('lengthEnd', node)
        if value is not None and 'lengthEnd' not in already_processed:
            already_processed.add('lengthEnd')
            try:
                self.lengthEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lengthEnd): %s' % exp)
            self.validate_t_grEqZero(self.lengthEnd)    # validate type t_grEqZero
        value = find_attr_value_('radiusStart', node)
        if value is not None and 'radiusStart' not in already_processed:
            already_processed.add('radiusStart')
            try:
                self.radiusStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radiusStart): %s' % exp)
            self.validate_t_grEqZero(self.radiusStart)    # validate type t_grEqZero
        value = find_attr_value_('radiusEnd', node)
        if value is not None and 'radiusEnd' not in already_processed:
            already_processed.add('radiusEnd')
            try:
                self.radiusEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radiusEnd): %s' % exp)
            self.validate_t_grEqZero(self.radiusEnd)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_repeat


class t_road_objects_object_outlines(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, outline=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if outline is None:
            self.outline = []
        else:
            self.outline = outline
        self.outline_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines.subclass:
            return t_road_objects_object_outlines.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_outline(self):
        return self.outline
    def set_outline(self, outline):
        self.outline = outline
    def add_outline(self, value):
        self.outline.append(value)
    def insert_outline_at(self, index, value):
        self.outline.insert(index, value)
    def replace_outline_at(self, index, value):
        self.outline[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.outline or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for outline_ in self.outline:
            namespaceprefix_ = self.outline_nsprefix_ + ':' if (UseCapturedNS_ and self.outline_nsprefix_) else ''
            outline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outline', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'outline':
            obj_ = t_road_objects_object_outlines_outline.factory(parent_object_=self)
            obj_.build(child_)
            self.outline.append(obj_)
            obj_.original_tagname_ = 'outline'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_outlines


class t_road_objects_object_outlines_outline(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, fillType=None, outer=None, closed=None, laneType=None, cornerRoad=None, cornerLocal=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.fillType = _cast(None, fillType)
        self.fillType_nsprefix_ = None
        self.outer = _cast(None, outer)
        self.outer_nsprefix_ = None
        self.closed = _cast(None, closed)
        self.closed_nsprefix_ = None
        self.laneType = _cast(None, laneType)
        self.laneType_nsprefix_ = None
        if cornerRoad is None:
            self.cornerRoad = []
        else:
            self.cornerRoad = cornerRoad
        self.cornerRoad_nsprefix_ = None
        if cornerLocal is None:
            self.cornerLocal = []
        else:
            self.cornerLocal = cornerLocal
        self.cornerLocal_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines_outline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines_outline.subclass:
            return t_road_objects_object_outlines_outline.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines_outline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cornerRoad(self):
        return self.cornerRoad
    def set_cornerRoad(self, cornerRoad):
        self.cornerRoad = cornerRoad
    def add_cornerRoad(self, value):
        self.cornerRoad.append(value)
    def insert_cornerRoad_at(self, index, value):
        self.cornerRoad.insert(index, value)
    def replace_cornerRoad_at(self, index, value):
        self.cornerRoad[index] = value
    def get_cornerLocal(self):
        return self.cornerLocal
    def set_cornerLocal(self, cornerLocal):
        self.cornerLocal = cornerLocal
    def add_cornerLocal(self, value):
        self.cornerLocal.append(value)
    def insert_cornerLocal_at(self, index, value):
        self.cornerLocal.insert(index, value)
    def replace_cornerLocal_at(self, index, value):
        self.cornerLocal[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_fillType(self):
        return self.fillType
    def set_fillType(self, fillType):
        self.fillType = fillType
    def get_outer(self):
        return self.outer
    def set_outer(self, outer):
        self.outer = outer
    def get_closed(self):
        return self.closed
    def set_closed(self, closed):
        self.closed = closed
    def get_laneType(self):
        return self.laneType
    def set_laneType(self, laneType):
        self.laneType = laneType
    def validate_e_outlineFillType(self, value):
        # Validate type e_outlineFillType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['grass', 'concrete', 'cobble', 'asphalt', 'pavement', 'gravel', 'soil']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_outlineFillType' % {"value" : value.encode("utf-8")} )
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['true', 'false']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_bool' % {"value" : value.encode("utf-8")} )
    def validate_e_laneType(self, value):
        # Validate type e_laneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'driving', 'stop', 'shoulder', 'biking', 'sidewalk', 'border', 'restricted', 'parking', 'bidirectional', 'median', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'entry', 'exit', 'offRamp', 'onRamp', 'connectingRamp', 'bus', 'taxi', 'HOV', 'mwyEntry', 'mwyExit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_laneType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cornerRoad or
            self.cornerLocal or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines_outline')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines_outline', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines_outline'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if 'fillType' not in already_processed:
            already_processed.add('fillType')
            outfile.write(' fillType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fillType), input_name='fillType')), ))
        if 'outer' not in already_processed:
            already_processed.add('outer')
            outfile.write(' outer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outer), input_name='outer')), ))
        if 'closed' not in already_processed:
            already_processed.add('closed')
            outfile.write(' closed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.closed), input_name='closed')), ))
        if 'laneType' not in already_processed:
            already_processed.add('laneType')
            outfile.write(' laneType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.laneType), input_name='laneType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerRoad_ in self.cornerRoad:
            namespaceprefix_ = self.cornerRoad_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerRoad_nsprefix_) else ''
            cornerRoad_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerRoad', pretty_print=pretty_print)
        for cornerLocal_ in self.cornerLocal:
            namespaceprefix_ = self.cornerLocal_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerLocal_nsprefix_) else ''
            cornerLocal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerLocal', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('fillType', node)
        if value is not None and 'fillType' not in already_processed:
            already_processed.add('fillType')
            self.fillType = value
            self.validate_e_outlineFillType(self.fillType)    # validate type e_outlineFillType
        value = find_attr_value_('outer', node)
        if value is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            self.outer = value
            self.validate_t_bool(self.outer)    # validate type t_bool
        value = find_attr_value_('closed', node)
        if value is not None and 'closed' not in already_processed:
            already_processed.add('closed')
            self.closed = value
            self.validate_t_bool(self.closed)    # validate type t_bool
        value = find_attr_value_('laneType', node)
        if value is not None and 'laneType' not in already_processed:
            already_processed.add('laneType')
            self.laneType = value
            self.validate_e_laneType(self.laneType)    # validate type e_laneType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cornerRoad':
            obj_ = t_road_objects_object_outlines_outline_cornerRoad.factory(parent_object_=self)
            obj_.build(child_)
            self.cornerRoad.append(obj_)
            obj_.original_tagname_ = 'cornerRoad'
        elif nodeName_ == 'cornerLocal':
            obj_ = t_road_objects_object_outlines_outline_cornerLocal.factory(parent_object_=self)
            obj_.build(child_)
            self.cornerLocal.append(obj_)
            obj_.original_tagname_ = 'cornerLocal'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_outlines_outline


class t_road_objects_object_outlines_outline_cornerRoad(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, dz=None, height=None, id=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.dz = _cast(float, dz)
        self.dz_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines_outline_cornerRoad)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines_outline_cornerRoad.subclass:
            return t_road_objects_object_outlines_outline_cornerRoad.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines_outline_cornerRoad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_dz(self):
        return self.dz
    def set_dz(self, dz):
        self.dz = dz
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerRoad', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines_outline_cornerRoad')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline_cornerRoad')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines_outline_cornerRoad', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines_outline_cornerRoad'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz="%s"' % self.gds_format_double(self.dz, input_name='dz'))
        if 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerRoad', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            try:
                self.dz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dz): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_outlines_outline_cornerRoad


class t_road_objects_object_outlines_outline_cornerLocal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, u=None, v=None, z=None, height=None, id=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.u = _cast(float, u)
        self.u_nsprefix_ = None
        self.v = _cast(float, v)
        self.v_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines_outline_cornerLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines_outline_cornerLocal.subclass:
            return t_road_objects_object_outlines_outline_cornerLocal.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines_outline_cornerLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_u(self):
        return self.u
    def set_u(self, u):
        self.u = u
    def get_v(self):
        return self.v
    def set_v(self, v):
        self.v = v
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerLocal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines_outline_cornerLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline_cornerLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines_outline_cornerLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines_outline_cornerLocal'):
        if 'u' not in already_processed:
            already_processed.add('u')
            outfile.write(' u="%s"' % self.gds_format_double(self.u, input_name='u'))
        if 'v' not in already_processed:
            already_processed.add('v')
            outfile.write(' v="%s"' % self.gds_format_double(self.v, input_name='v'))
        if 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('u', node)
        if value is not None and 'u' not in already_processed:
            already_processed.add('u')
            try:
                self.u = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (u): %s' % exp)
        value = find_attr_value_('v', node)
        if value is not None and 'v' not in already_processed:
            already_processed.add('v')
            try:
                self.v = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (v): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            try:
                self.z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_outlines_outline_cornerLocal


class t_road_objects_object_material(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, surface=None, friction=None, roughness=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
        self.friction = _cast(float, friction)
        self.friction_nsprefix_ = None
        self.roughness = _cast(float, roughness)
        self.roughness_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_material.subclass:
            return t_road_objects_object_material.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_friction(self):
        return self.friction
    def set_friction(self, friction):
        self.friction = friction
    def get_roughness(self):
        return self.roughness
    def set_roughness(self, roughness):
        self.roughness = roughness
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_material')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_material', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_material'):
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
        if self.roughness is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            outfile.write(' roughness="%s"' % self.gds_format_double(self.roughness, input_name='roughness'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_material', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            try:
                self.friction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (friction): %s' % exp)
            self.validate_t_grEqZero(self.friction)    # validate type t_grEqZero
        value = find_attr_value_('roughness', node)
        if value is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            try:
                self.roughness = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roughness): %s' % exp)
            self.validate_t_grEqZero(self.roughness)    # validate type t_grEqZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_material


class t_road_objects_object_laneValidity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fromLane=None, toLane=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fromLane = _cast(int, fromLane)
        self.fromLane_nsprefix_ = None
        self.toLane = _cast(int, toLane)
        self.toLane_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_laneValidity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_laneValidity.subclass:
            return t_road_objects_object_laneValidity.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_laneValidity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_fromLane(self):
        return self.fromLane
    def set_fromLane(self, fromLane):
        self.fromLane = fromLane
    def get_toLane(self):
        return self.toLane
    def set_toLane(self, toLane):
        self.toLane = toLane
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_laneValidity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_laneValidity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_laneValidity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_laneValidity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_laneValidity'):
        if 'fromLane' not in already_processed:
            already_processed.add('fromLane')
            outfile.write(' fromLane="%s"' % self.gds_format_integer(self.fromLane, input_name='fromLane'))
        if 'toLane' not in already_processed:
            already_processed.add('toLane')
            outfile.write(' toLane="%s"' % self.gds_format_integer(self.toLane, input_name='toLane'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_laneValidity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fromLane', node)
        if value is not None and 'fromLane' not in already_processed:
            already_processed.add('fromLane')
            try:
                self.fromLane = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('toLane', node)
        if value is not None and 'toLane' not in already_processed:
            already_processed.add('toLane')
            try:
                self.toLane = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_laneValidity


class t_road_objects_object_parkingSpace(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, access=None, restrictions=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.access = _cast(None, access)
        self.access_nsprefix_ = None
        self.restrictions = _cast(None, restrictions)
        self.restrictions_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_parkingSpace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_parkingSpace.subclass:
            return t_road_objects_object_parkingSpace.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_parkingSpace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_restrictions(self):
        return self.restrictions
    def set_restrictions(self, restrictions):
        self.restrictions = restrictions
    def validate_e_road_objects_object_parkingSpace_access(self, value):
        # Validate type e_road_objects_object_parkingSpace_access, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['all', 'car', 'women', 'handicapped', 'bus', 'truck', 'electric', 'residents']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_objects_object_parkingSpace_access' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_parkingSpace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_parkingSpace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_parkingSpace')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_parkingSpace', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_parkingSpace'):
        if 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.access), input_name='access')), ))
        if self.restrictions is not None and 'restrictions' not in already_processed:
            already_processed.add('restrictions')
            outfile.write(' restrictions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restrictions), input_name='restrictions')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_parkingSpace', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
            self.validate_e_road_objects_object_parkingSpace_access(self.access)    # validate type e_road_objects_object_parkingSpace_access
        value = find_attr_value_('restrictions', node)
        if value is not None and 'restrictions' not in already_processed:
            already_processed.add('restrictions')
            self.restrictions = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_parkingSpace


class t_road_objects_object_markings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, marking=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if marking is None:
            self.marking = []
        else:
            self.marking = marking
        self.marking_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_markings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_markings.subclass:
            return t_road_objects_object_markings.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_markings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_marking(self):
        return self.marking
    def set_marking(self, marking):
        self.marking = marking
    def add_marking(self, value):
        self.marking.append(value)
    def insert_marking_at(self, index, value):
        self.marking.insert(index, value)
    def replace_marking_at(self, index, value):
        self.marking[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.marking or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_markings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_markings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_markings'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for marking_ in self.marking:
            namespaceprefix_ = self.marking_nsprefix_ + ':' if (UseCapturedNS_ and self.marking_nsprefix_) else ''
            marking_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='marking', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'marking':
            obj_ = t_road_objects_object_markings_marking.factory(parent_object_=self)
            obj_.build(child_)
            self.marking.append(obj_)
            obj_.original_tagname_ = 'marking'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_markings


class t_road_objects_object_markings_marking(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, side=None, weight=None, width=None, color=None, zOffset=None, spaceLength=None, lineLength=None, startOffset=None, stopOffset=None, cornerReference=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.spaceLength = _cast(float, spaceLength)
        self.spaceLength_nsprefix_ = None
        self.lineLength = _cast(float, lineLength)
        self.lineLength_nsprefix_ = None
        self.startOffset = _cast(float, startOffset)
        self.startOffset_nsprefix_ = None
        self.stopOffset = _cast(float, stopOffset)
        self.stopOffset_nsprefix_ = None
        if cornerReference is None:
            self.cornerReference = []
        else:
            self.cornerReference = cornerReference
        self.cornerReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_markings_marking)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_markings_marking.subclass:
            return t_road_objects_object_markings_marking.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_markings_marking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cornerReference(self):
        return self.cornerReference
    def set_cornerReference(self, cornerReference):
        self.cornerReference = cornerReference
    def add_cornerReference(self, value):
        self.cornerReference.append(value)
    def insert_cornerReference_at(self, index, value):
        self.cornerReference.insert(index, value)
    def replace_cornerReference_at(self, index, value):
        self.cornerReference[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_spaceLength(self):
        return self.spaceLength
    def set_spaceLength(self, spaceLength):
        self.spaceLength = spaceLength
    def get_lineLength(self):
        return self.lineLength
    def set_lineLength(self, lineLength):
        self.lineLength = lineLength
    def get_startOffset(self):
        return self.startOffset
    def set_startOffset(self, startOffset):
        self.startOffset = startOffset
    def get_stopOffset(self):
        return self.stopOffset
    def set_stopOffset(self, stopOffset):
        self.stopOffset = stopOffset
    def validate_e_sideType(self, value):
        # Validate type e_sideType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['left', 'right', 'front', 'rear']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_sideType' % {"value" : value.encode("utf-8")} )
    def validate_e_roadMarkWeight(self, value):
        # Validate type e_roadMarkWeight, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['standard', 'bold']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkWeight' % {"value" : value.encode("utf-8")} )
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_roadMarkColor(self, value):
        # Validate type e_roadMarkColor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow', 'orange']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_roadMarkColor' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cornerReference or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_markings_marking')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings_marking')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_markings_marking', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_markings_marking'):
        if 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weight), input_name='weight')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if 'spaceLength' not in already_processed:
            already_processed.add('spaceLength')
            outfile.write(' spaceLength="%s"' % self.gds_format_double(self.spaceLength, input_name='spaceLength'))
        if 'lineLength' not in already_processed:
            already_processed.add('lineLength')
            outfile.write(' lineLength="%s"' % self.gds_format_double(self.lineLength, input_name='lineLength'))
        if 'startOffset' not in already_processed:
            already_processed.add('startOffset')
            outfile.write(' startOffset="%s"' % self.gds_format_double(self.startOffset, input_name='startOffset'))
        if 'stopOffset' not in already_processed:
            already_processed.add('stopOffset')
            outfile.write(' stopOffset="%s"' % self.gds_format_double(self.stopOffset, input_name='stopOffset'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerReference_ in self.cornerReference:
            namespaceprefix_ = self.cornerReference_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerReference_nsprefix_) else ''
            cornerReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerReference', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_e_sideType(self.side)    # validate type e_sideType
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_e_roadMarkWeight(self.weight)    # validate type e_roadMarkWeight
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_e_roadMarkColor(self.color)    # validate type e_roadMarkColor
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
            self.validate_t_grEqZero(self.zOffset)    # validate type t_grEqZero
        value = find_attr_value_('spaceLength', node)
        if value is not None and 'spaceLength' not in already_processed:
            already_processed.add('spaceLength')
            try:
                self.spaceLength = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (spaceLength): %s' % exp)
            self.validate_t_grEqZero(self.spaceLength)    # validate type t_grEqZero
        value = find_attr_value_('lineLength', node)
        if value is not None and 'lineLength' not in already_processed:
            already_processed.add('lineLength')
            try:
                self.lineLength = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lineLength): %s' % exp)
            self.validate_t_grEqZero(self.lineLength)    # validate type t_grEqZero
        value = find_attr_value_('startOffset', node)
        if value is not None and 'startOffset' not in already_processed:
            already_processed.add('startOffset')
            try:
                self.startOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (startOffset): %s' % exp)
        value = find_attr_value_('stopOffset', node)
        if value is not None and 'stopOffset' not in already_processed:
            already_processed.add('stopOffset')
            try:
                self.stopOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stopOffset): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cornerReference':
            obj_ = t_road_objects_object_markings_marking_cornerReference.factory(parent_object_=self)
            obj_.build(child_)
            self.cornerReference.append(obj_)
            obj_.original_tagname_ = 'cornerReference'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_markings_marking


class t_road_objects_object_markings_marking_cornerReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_markings_marking_cornerReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_markings_marking_cornerReference.subclass:
            return t_road_objects_object_markings_marking_cornerReference.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_markings_marking_cornerReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking_cornerReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_markings_marking_cornerReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings_marking_cornerReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_markings_marking_cornerReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_markings_marking_cornerReference'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking_cornerReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_markings_marking_cornerReference


class t_road_objects_object_borders(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, border=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if border is None:
            self.border = []
        else:
            self.border = border
        self.border_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_borders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_borders.subclass:
            return t_road_objects_object_borders.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_borders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_border(self):
        return self.border
    def set_border(self, border):
        self.border = border
    def add_border(self, value):
        self.border.append(value)
    def insert_border_at(self, index, value):
        self.border.insert(index, value)
    def replace_border_at(self, index, value):
        self.border[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.border or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_borders')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_borders')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_borders', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_borders'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for border_ in self.border:
            namespaceprefix_ = self.border_nsprefix_ + ':' if (UseCapturedNS_ and self.border_nsprefix_) else ''
            border_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='border', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'border':
            obj_ = t_road_objects_object_borders_border.factory(parent_object_=self)
            obj_.build(child_)
            self.border.append(obj_)
            obj_.original_tagname_ = 'border'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_borders


class t_road_objects_object_borders_border(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, type_=None, outlineId=None, useCompleteOutline=None, cornerReference=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.outlineId = _cast(int, outlineId)
        self.outlineId_nsprefix_ = None
        self.useCompleteOutline = _cast(None, useCompleteOutline)
        self.useCompleteOutline_nsprefix_ = None
        if cornerReference is None:
            self.cornerReference = []
        else:
            self.cornerReference = cornerReference
        self.cornerReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_borders_border)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_borders_border.subclass:
            return t_road_objects_object_borders_border.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_borders_border(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cornerReference(self):
        return self.cornerReference
    def set_cornerReference(self, cornerReference):
        self.cornerReference = cornerReference
    def add_cornerReference(self, value):
        self.cornerReference.append(value)
    def insert_cornerReference_at(self, index, value):
        self.cornerReference.insert(index, value)
    def replace_cornerReference_at(self, index, value):
        self.cornerReference[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_outlineId(self):
        return self.outlineId
    def set_outlineId(self, outlineId):
        self.outlineId = outlineId
    def get_useCompleteOutline(self):
        return self.useCompleteOutline
    def set_useCompleteOutline(self, useCompleteOutline):
        self.useCompleteOutline = useCompleteOutline
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_borderType(self, value):
        # Validate type e_borderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['concrete', 'curb']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_borderType' % {"value" : value.encode("utf-8")} )
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['true', 'false']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_bool' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cornerReference or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders_border', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_borders_border')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_borders_border')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_borders_border', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_borders_border'):
        if 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if 'outlineId' not in already_processed:
            already_processed.add('outlineId')
            outfile.write(' outlineId="%s"' % self.gds_format_integer(self.outlineId, input_name='outlineId'))
        if self.useCompleteOutline is not None and 'useCompleteOutline' not in already_processed:
            already_processed.add('useCompleteOutline')
            outfile.write(' useCompleteOutline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.useCompleteOutline), input_name='useCompleteOutline')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders_border', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerReference_ in self.cornerReference:
            namespaceprefix_ = self.cornerReference_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerReference_nsprefix_) else ''
            cornerReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerReference', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_borderType(self.type_)    # validate type e_borderType
        value = find_attr_value_('outlineId', node)
        if value is not None and 'outlineId' not in already_processed:
            already_processed.add('outlineId')
            try:
                self.outlineId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.outlineId < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('useCompleteOutline', node)
        if value is not None and 'useCompleteOutline' not in already_processed:
            already_processed.add('useCompleteOutline')
            self.useCompleteOutline = value
            self.validate_t_bool(self.useCompleteOutline)    # validate type t_bool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cornerReference':
            obj_ = t_road_objects_object_markings_marking_cornerReference.factory(parent_object_=self)
            obj_.build(child_)
            self.cornerReference.append(obj_)
            obj_.original_tagname_ = 'cornerReference'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_object_borders_border


class t_road_objects_objectReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, id=None, zOffset=None, validLength=None, orientation=None, validity=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.validLength = _cast(float, validLength)
        self.validLength_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_objectReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_objectReference.subclass:
            return t_road_objects_objectReference.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_objectReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_validLength(self):
        return self.validLength
    def set_validLength(self, validLength):
        self.validLength = validLength
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_orientation' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.validity or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_objectReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_objectReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_objectReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_objectReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_objectReference'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if 'validLength' not in already_processed:
            already_processed.add('validLength')
            outfile.write(' validLength="%s"' % self.gds_format_double(self.validLength, input_name='validLength'))
        if 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_objectReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
        value = find_attr_value_('validLength', node)
        if value is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            try:
                self.validLength = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (validLength): %s' % exp)
            self.validate_t_grEqZero(self.validLength)    # validate type t_grEqZero
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_objectReference


class t_road_objects_tunnel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, length=None, name=None, id=None, type_=None, lighting=None, daylight=None, validity=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.lighting = _cast(float, lighting)
        self.lighting_nsprefix_ = None
        self.daylight = _cast(float, daylight)
        self.daylight_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_tunnel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_tunnel.subclass:
            return t_road_objects_tunnel.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_tunnel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_lighting(self):
        return self.lighting
    def set_lighting(self, lighting):
        self.lighting = lighting
    def get_daylight(self):
        return self.daylight
    def set_daylight(self, daylight):
        self.daylight = daylight
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_tunnelType(self, value):
        # Validate type e_tunnelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['standard', 'underpass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_tunnelType' % {"value" : value.encode("utf-8")} )
    def validate_t_zeroOne(self, value):
        # Validate type t_zeroOne, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_zeroOne' % {"value" : value} )
            if value > 1.0:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on t_zeroOne' % {"value" : value} )
    def hasContent_(self):
        if (
            self.validity or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_tunnel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_tunnel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_tunnel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_tunnel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_tunnel'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.lighting is not None and 'lighting' not in already_processed:
            already_processed.add('lighting')
            outfile.write(' lighting="%s"' % self.gds_format_double(self.lighting, input_name='lighting'))
        if self.daylight is not None and 'daylight' not in already_processed:
            already_processed.add('daylight')
            outfile.write(' daylight="%s"' % self.gds_format_double(self.daylight, input_name='daylight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_tunnel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_tunnelType(self.type_)    # validate type e_tunnelType
        value = find_attr_value_('lighting', node)
        if value is not None and 'lighting' not in already_processed:
            already_processed.add('lighting')
            try:
                self.lighting = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lighting): %s' % exp)
            self.validate_t_zeroOne(self.lighting)    # validate type t_zeroOne
        value = find_attr_value_('daylight', node)
        if value is not None and 'daylight' not in already_processed:
            already_processed.add('daylight')
            try:
                self.daylight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (daylight): %s' % exp)
            self.validate_t_zeroOne(self.daylight)    # validate type t_zeroOne
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_tunnel


class t_road_objects_bridge(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, length=None, name=None, id=None, type_=None, validity=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_bridge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_bridge.subclass:
            return t_road_objects_bridge.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_bridge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_bridgeType(self, value):
        # Validate type e_bridgeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['concrete', 'steel', 'brick', 'wood']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_bridgeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.validity or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_bridge', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_bridge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_bridge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_bridge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_bridge'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_bridge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_bridgeType(self.type_)    # validate type e_bridgeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_objects_bridge


class t_road_signals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, signal=None, signalReference=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if signal is None:
            self.signal = []
        else:
            self.signal = signal
        self.signal_nsprefix_ = None
        if signalReference is None:
            self.signalReference = []
        else:
            self.signalReference = signalReference
        self.signalReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals.subclass:
            return t_road_signals.subclass(*args_, **kwargs_)
        else:
            return t_road_signals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_signal(self):
        return self.signal
    def set_signal(self, signal):
        self.signal = signal
    def add_signal(self, value):
        self.signal.append(value)
    def insert_signal_at(self, index, value):
        self.signal.insert(index, value)
    def replace_signal_at(self, index, value):
        self.signal[index] = value
    def get_signalReference(self):
        return self.signalReference
    def set_signalReference(self, signalReference):
        self.signalReference = signalReference
    def add_signalReference(self, value):
        self.signalReference.append(value)
    def insert_signalReference_at(self, index, value):
        self.signalReference.insert(index, value)
    def replace_signalReference_at(self, index, value):
        self.signalReference[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.signal or
            self.signalReference or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for signal_ in self.signal:
            namespaceprefix_ = self.signal_nsprefix_ + ':' if (UseCapturedNS_ and self.signal_nsprefix_) else ''
            signal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signal', pretty_print=pretty_print)
        for signalReference_ in self.signalReference:
            namespaceprefix_ = self.signalReference_nsprefix_ + ':' if (UseCapturedNS_ and self.signalReference_nsprefix_) else ''
            signalReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signalReference', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'signal':
            obj_ = t_road_signals_signal.factory(parent_object_=self)
            obj_.build(child_)
            self.signal.append(obj_)
            obj_.original_tagname_ = 'signal'
        elif nodeName_ == 'signalReference':
            obj_ = t_road_signals_signalReference.factory(parent_object_=self)
            obj_.build(child_)
            self.signalReference.append(obj_)
            obj_.original_tagname_ = 'signalReference'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals


class t_road_signals_signal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, id=None, name=None, dynamic=None, orientation=None, zOffset=None, country=None, countryRevision=None, type_=None, subtype=None, value=None, unit=None, height=None, width=None, text=None, hOffset=None, pitch=None, roll=None, validity=None, dependency=None, reference=None, positionRoad=None, positionInertial=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dynamic = _cast(None, dynamic)
        self.dynamic_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.country = _cast(None, country)
        self.country_nsprefix_ = None
        self.countryRevision = _cast(None, countryRevision)
        self.countryRevision_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.subtype = _cast(None, subtype)
        self.subtype_nsprefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        self.positionRoad = positionRoad
        self.positionRoad_nsprefix_ = None
        self.positionInertial = positionInertial
        self.positionInertial_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal.subclass:
            return t_road_signals_signal.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_dependency(self):
        return self.dependency
    def set_dependency(self, dependency):
        self.dependency = dependency
    def add_dependency(self, value):
        self.dependency.append(value)
    def insert_dependency_at(self, index, value):
        self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value):
        self.dependency[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_positionRoad(self):
        return self.positionRoad
    def set_positionRoad(self, positionRoad):
        self.positionRoad = positionRoad
    def get_positionInertial(self):
        return self.positionInertial
    def set_positionInertial(self, positionInertial):
        self.positionInertial = positionInertial
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_dynamic(self):
        return self.dynamic
    def set_dynamic(self, dynamic):
        self.dynamic = dynamic
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_countryRevision(self):
        return self.countryRevision
    def set_countryRevision(self, countryRevision):
        self.countryRevision = countryRevision
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_subtype(self):
        return self.subtype
    def set_subtype(self, subtype):
        self.subtype = subtype
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_hOffset(self):
        return self.hOffset
    def set_hOffset(self, hOffset):
        self.hOffset = hOffset
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_roll(self):
        return self.roll
    def set_roll(self, roll):
        self.roll = roll
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_t_yesNo(self, value):
        # Validate type t_yesNo, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on t_yesNo' % {"value" : value.encode("utf-8")} )
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_orientation' % {"value" : value.encode("utf-8")} )
    def validate_e_countryCode(self, value):
        # Validate type e_countryCode, a restriction on None.
        pass
    def validate_e_unit(self, value):
        # Validate type e_unit, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.validity or
            self.dependency or
            self.reference or
            self.positionRoad is not None or
            self.positionInertial is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            outfile.write(' dynamic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dynamic), input_name='dynamic')), ))
        if 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (quote_attrib(self.country), ))
        if self.countryRevision is not None and 'countryRevision' not in already_processed:
            already_processed.add('countryRevision')
            outfile.write(' countryRevision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.countryRevision), input_name='countryRevision')), ))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if 'subtype' not in already_processed:
            already_processed.add('subtype')
            outfile.write(' subtype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subtype), input_name='subtype')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dependency', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.positionRoad is not None:
            namespaceprefix_ = self.positionRoad_nsprefix_ + ':' if (UseCapturedNS_ and self.positionRoad_nsprefix_) else ''
            self.positionRoad.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionRoad', pretty_print=pretty_print)
        if self.positionInertial is not None:
            namespaceprefix_ = self.positionInertial_nsprefix_ + ':' if (UseCapturedNS_ and self.positionInertial_nsprefix_) else ''
            self.positionInertial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionInertial', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dynamic', node)
        if value is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            self.dynamic = value
            self.validate_t_yesNo(self.dynamic)    # validate type t_yesNo
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
            self.validate_e_countryCode(self.country)    # validate type e_countryCode
        value = find_attr_value_('countryRevision', node)
        if value is not None and 'countryRevision' not in already_processed:
            already_processed.add('countryRevision')
            self.countryRevision = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('subtype', node)
        if value is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            self.subtype = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_e_unit(self.unit)    # validate type e_unit
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
            self.validate_t_grEqZero(self.height)    # validate type t_grEqZero
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            try:
                self.hOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hOffset): %s' % exp)
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            try:
                self.pitch = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pitch): %s' % exp)
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            try:
                self.roll = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roll): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dependency':
            obj_ = t_road_signals_signal_dependency.factory(parent_object_=self)
            obj_.build(child_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'reference':
            obj_ = t_road_signals_signal_reference.factory(parent_object_=self)
            obj_.build(child_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'positionRoad':
            obj_ = t_road_signals_signal_positionRoad.factory(parent_object_=self)
            obj_.build(child_)
            self.positionRoad = obj_
            obj_.original_tagname_ = 'positionRoad'
        elif nodeName_ == 'positionInertial':
            obj_ = t_road_signals_signal_positionInertial.factory(parent_object_=self)
            obj_.build(child_)
            self.positionInertial = obj_
            obj_.original_tagname_ = 'positionInertial'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals_signal


class t_road_signals_signal_dependency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_dependency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_dependency.subclass:
            return t_road_signals_signal_dependency.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_dependency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_dependency', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_dependency')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_dependency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_dependency', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_dependency'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_dependency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals_signal_dependency


class t_road_signals_signal_reference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, elementType=None, elementId=None, type_=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_reference.subclass:
            return t_road_signals_signal_reference.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_elementType(self):
        return self.elementType
    def set_elementType(self, elementType):
        self.elementType = elementType
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_e_road_signals_signal_reference_elementType(self, value):
        # Validate type e_road_signals_signal_reference_elementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['object', 'signal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_signals_signal_reference_elementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_reference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_reference'):
        if 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
        if 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
            self.validate_e_road_signals_signal_reference_elementType(self.elementType)    # validate type e_road_signals_signal_reference_elementType
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals_signal_reference


class t_road_signals_signal_positionRoad(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, roadId=None, s=None, t=None, zOffset=None, hOffset=None, pitch=None, roll=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.roadId = _cast(None, roadId)
        self.roadId_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_positionRoad)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_positionRoad.subclass:
            return t_road_signals_signal_positionRoad.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_positionRoad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_roadId(self):
        return self.roadId
    def set_roadId(self, roadId):
        self.roadId = roadId
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_hOffset(self):
        return self.hOffset
    def set_hOffset(self, hOffset):
        self.hOffset = hOffset
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_roll(self):
        return self.roll
    def set_roll(self, roll):
        self.roll = roll
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionRoad', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_positionRoad')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_positionRoad')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_positionRoad', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_positionRoad'):
        if 'roadId' not in already_processed:
            already_processed.add('roadId')
            outfile.write(' roadId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.roadId), input_name='roadId')), ))
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionRoad', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roadId', node)
        if value is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            self.roadId = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            try:
                self.hOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hOffset): %s' % exp)
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            try:
                self.pitch = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pitch): %s' % exp)
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            try:
                self.roll = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roll): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals_signal_positionRoad


class t_road_signals_signal_positionInertial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, z=None, hdg=None, pitch=None, roll=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_positionInertial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_positionInertial.subclass:
            return t_road_signals_signal_positionInertial.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_positionInertial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    def get_hdg(self):
        return self.hdg
    def set_hdg(self, hdg):
        self.hdg = hdg
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_roll(self):
        return self.roll
    def set_roll(self, roll):
        self.roll = roll
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionInertial', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_positionInertial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_positionInertial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_positionInertial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_positionInertial'):
        if 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionInertial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            try:
                self.z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            try:
                self.hdg = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hdg): %s' % exp)
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            try:
                self.pitch = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pitch): %s' % exp)
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            try:
                self.roll = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roll): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals_signal_positionInertial


class t_road_signals_signalReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, s=None, t=None, id=None, orientation=None, validity=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signalReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signalReference.subclass:
            return t_road_signals_signalReference.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signalReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validity(self):
        return self.validity
    def set_validity(self, validity):
        self.validity = validity
    def add_validity(self, value):
        self.validity.append(value)
    def insert_validity_at(self, index, value):
        self.validity.insert(index, value)
    def replace_validity_at(self, index, value):
        self.validity[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_t(self):
        return self.t
    def set_t(self, t):
        self.t = t
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_orientation' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.validity or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signalReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signalReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signalReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signalReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signalReference'):
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signalReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            try:
                self.t = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_signals_signalReference


class t_road_surface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CRG=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CRG is None:
            self.CRG = []
        else:
            self.CRG = CRG
        self.CRG_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_surface.subclass:
            return t_road_surface.subclass(*args_, **kwargs_)
        else:
            return t_road_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CRG(self):
        return self.CRG
    def set_CRG(self, CRG):
        self.CRG = CRG
    def add_CRG(self, value):
        self.CRG.append(value)
    def insert_CRG_at(self, index, value):
        self.CRG.insert(index, value)
    def replace_CRG_at(self, index, value):
        self.CRG[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.CRG or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_surface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_surface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_surface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_surface'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CRG_ in self.CRG:
            namespaceprefix_ = self.CRG_nsprefix_ + ':' if (UseCapturedNS_ and self.CRG_nsprefix_) else ''
            CRG_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRG', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CRG':
            obj_ = t_road_surface_CRG.factory(parent_object_=self)
            obj_.build(child_)
            self.CRG.append(obj_)
            obj_.original_tagname_ = 'CRG'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_surface


class t_road_surface_CRG(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file=None, sStart=None, sEnd=None, orientation=None, mode=None, purpose=None, sOffset=None, tOffset=None, zOffset=None, zScale=None, hOffset=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.mode = _cast(None, mode)
        self.mode_nsprefix_ = None
        self.purpose = _cast(None, purpose)
        self.purpose_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.zScale = _cast(float, zScale)
        self.zScale_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_surface_CRG)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_surface_CRG.subclass:
            return t_road_surface_CRG.subclass(*args_, **kwargs_)
        else:
            return t_road_surface_CRG(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def get_sStart(self):
        return self.sStart
    def set_sStart(self, sStart):
        self.sStart = sStart
    def get_sEnd(self):
        return self.sEnd
    def set_sEnd(self, sEnd):
        self.sEnd = sEnd
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_sOffset(self):
        return self.sOffset
    def set_sOffset(self, sOffset):
        self.sOffset = sOffset
    def get_tOffset(self):
        return self.tOffset
    def set_tOffset(self, tOffset):
        self.tOffset = tOffset
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_zScale(self):
        return self.zScale
    def set_zScale(self, zScale):
        self.zScale = zScale
    def get_hOffset(self):
        return self.hOffset
    def set_hOffset(self, hOffset):
        self.hOffset = hOffset
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_direction(self, value):
        # Validate type e_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['same', 'opposite']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_direction' % {"value" : value.encode("utf-8")} )
    def validate_e_road_surface_CRG_mode(self, value):
        # Validate type e_road_surface_CRG_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['attached', 'attached0', 'genuine', 'global']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_surface_CRG_mode' % {"value" : value.encode("utf-8")} )
    def validate_e_road_surface_CRG_purpose(self, value):
        # Validate type e_road_surface_CRG_purpose, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['elevation', 'friction']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_surface_CRG_purpose' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface_CRG', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_surface_CRG')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_surface_CRG')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_surface_CRG', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_surface_CRG'):
        if 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
        if 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')), ))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.zScale is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            outfile.write(' zScale="%s"' % self.gds_format_double(self.zScale, input_name='zScale'))
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface_CRG', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            try:
                self.sStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sStart): %s' % exp)
            self.validate_t_grEqZero(self.sStart)    # validate type t_grEqZero
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            try:
                self.sEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sEnd): %s' % exp)
            self.validate_t_grEqZero(self.sEnd)    # validate type t_grEqZero
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_direction(self.orientation)    # validate type e_direction
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_e_road_surface_CRG_mode(self.mode)    # validate type e_road_surface_CRG_mode
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
            self.validate_e_road_surface_CRG_purpose(self.purpose)    # validate type e_road_surface_CRG_purpose
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            try:
                self.sOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sOffset): %s' % exp)
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            try:
                self.tOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tOffset): %s' % exp)
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
        value = find_attr_value_('zScale', node)
        if value is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            try:
                self.zScale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zScale): %s' % exp)
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            try:
                self.hOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hOffset): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_surface_CRG


class t_road_railroad(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, switch=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if switch is None:
            self.switch = []
        else:
            self.switch = switch
        self.switch_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad.subclass:
            return t_road_railroad.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_switch(self):
        return self.switch
    def set_switch(self, switch):
        self.switch = switch
    def add_switch(self, value):
        self.switch.append(value)
    def insert_switch_at(self, index, value):
        self.switch.insert(index, value)
    def replace_switch_at(self, index, value):
        self.switch[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.switch or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for switch_ in self.switch:
            namespaceprefix_ = self.switch_nsprefix_ + ':' if (UseCapturedNS_ and self.switch_nsprefix_) else ''
            switch_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='switch', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'switch':
            obj_ = t_road_railroad_switch.factory(parent_object_=self)
            obj_.build(child_)
            self.switch.append(obj_)
            obj_.original_tagname_ = 'switch'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_railroad


class t_road_railroad_switch(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, position=None, mainTrack=None, sideTrack=None, partner=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.position = _cast(None, position)
        self.position_nsprefix_ = None
        self.mainTrack = mainTrack
        self.mainTrack_nsprefix_ = None
        self.sideTrack = sideTrack
        self.sideTrack_nsprefix_ = None
        self.partner = partner
        self.partner_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch.subclass:
            return t_road_railroad_switch.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mainTrack(self):
        return self.mainTrack
    def set_mainTrack(self, mainTrack):
        self.mainTrack = mainTrack
    def get_sideTrack(self):
        return self.sideTrack
    def set_sideTrack(self, sideTrack):
        self.sideTrack = sideTrack
    def get_partner(self):
        return self.partner
    def set_partner(self, partner):
        self.partner = partner
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def validate_e_road_railroad_switch_position(self, value):
        # Validate type e_road_railroad_switch_position, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dynamic', 'straight', 'turn']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_railroad_switch_position' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.mainTrack is not None or
            self.sideTrack is not None or
            self.partner is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch'):
        if 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mainTrack is not None:
            namespaceprefix_ = self.mainTrack_nsprefix_ + ':' if (UseCapturedNS_ and self.mainTrack_nsprefix_) else ''
            self.mainTrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mainTrack', pretty_print=pretty_print)
        if self.sideTrack is not None:
            namespaceprefix_ = self.sideTrack_nsprefix_ + ':' if (UseCapturedNS_ and self.sideTrack_nsprefix_) else ''
            self.sideTrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sideTrack', pretty_print=pretty_print)
        if self.partner is not None:
            namespaceprefix_ = self.partner_nsprefix_ + ':' if (UseCapturedNS_ and self.partner_nsprefix_) else ''
            self.partner.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partner', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
            self.validate_e_road_railroad_switch_position(self.position)    # validate type e_road_railroad_switch_position
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mainTrack':
            obj_ = t_road_railroad_switch_mainTrack.factory(parent_object_=self)
            obj_.build(child_)
            self.mainTrack = obj_
            obj_.original_tagname_ = 'mainTrack'
        elif nodeName_ == 'sideTrack':
            obj_ = t_road_railroad_switch_sideTrack.factory(parent_object_=self)
            obj_.build(child_)
            self.sideTrack = obj_
            obj_.original_tagname_ = 'sideTrack'
        elif nodeName_ == 'partner':
            obj_ = t_road_railroad_switch_partner.factory(parent_object_=self)
            obj_.build(child_)
            self.partner = obj_
            obj_.original_tagname_ = 'partner'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_railroad_switch


class t_road_railroad_switch_mainTrack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, s=None, dir=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch_mainTrack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch_mainTrack.subclass:
            return t_road_railroad_switch_mainTrack.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch_mainTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_elementDir' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_mainTrack', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch_mainTrack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_mainTrack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch_mainTrack', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch_mainTrack'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_mainTrack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.validate_e_elementDir(self.dir)    # validate type e_elementDir
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_railroad_switch_mainTrack


class t_road_railroad_switch_sideTrack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, s=None, dir=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch_sideTrack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch_sideTrack.subclass:
            return t_road_railroad_switch_sideTrack.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch_sideTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_elementDir' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_sideTrack', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch_sideTrack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_sideTrack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch_sideTrack', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch_sideTrack'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_sideTrack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            try:
                self.s = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (s): %s' % exp)
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.validate_e_elementDir(self.dir)    # validate type e_elementDir
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_railroad_switch_sideTrack


class t_road_railroad_switch_partner(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch_partner)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch_partner.subclass:
            return t_road_railroad_switch_partner.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch_partner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_partner', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch_partner')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_partner')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch_partner', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch_partner'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_partner', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_road_railroad_switch_partner


class t_controller(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, sequence=None, control=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_controller)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_controller.subclass:
            return t_controller.subclass(*args_, **kwargs_)
        else:
            return t_controller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def hasContent_(self):
        if (
            self.control or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_controller')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_controller')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_controller', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_controller'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            try:
                self.sequence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.sequence < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'control':
            obj_ = t_controller_control.factory(parent_object_=self)
            obj_.build(child_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_controller


class t_controller_control(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, signalId=None, type_=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.signalId = _cast(None, signalId)
        self.signalId_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_controller_control)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_controller_control.subclass:
            return t_controller_control.subclass(*args_, **kwargs_)
        else:
            return t_controller_control(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_signalId(self):
        return self.signalId
    def set_signalId(self, signalId):
        self.signalId = signalId
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller_control', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_controller_control')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_controller_control')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_controller_control', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_controller_control'):
        if 'signalId' not in already_processed:
            already_processed.add('signalId')
            outfile.write(' signalId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.signalId), input_name='signalId')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller_control', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('signalId', node)
        if value is not None and 'signalId' not in already_processed:
            already_processed.add('signalId')
            self.signalId = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_controller_control


class t_junction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, type_=None, connection=None, priority=None, controller=None, surface=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if connection is None:
            self.connection = []
        else:
            self.connection = connection
        self.connection_nsprefix_ = None
        if priority is None:
            self.priority = []
        else:
            self.priority = priority
        self.priority_nsprefix_ = None
        if controller is None:
            self.controller = []
        else:
            self.controller = controller
        self.controller_nsprefix_ = None
        self.surface = surface
        self.surface_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction.subclass:
            return t_junction.subclass(*args_, **kwargs_)
        else:
            return t_junction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_connection(self):
        return self.connection
    def set_connection(self, connection):
        self.connection = connection
    def add_connection(self, value):
        self.connection.append(value)
    def insert_connection_at(self, index, value):
        self.connection.insert(index, value)
    def replace_connection_at(self, index, value):
        self.connection[index] = value
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    def add_priority(self, value):
        self.priority.append(value)
    def insert_priority_at(self, index, value):
        self.priority.insert(index, value)
    def replace_priority_at(self, index, value):
        self.priority[index] = value
    def get_controller(self):
        return self.controller
    def set_controller(self, controller):
        self.controller = controller
    def add_controller(self, value):
        self.controller.append(value)
    def insert_controller_at(self, index, value):
        self.controller.insert(index, value)
    def replace_controller_at(self, index, value):
        self.controller[index] = value
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_t_junction_id(self, value):
        # Validate type t_junction_id, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_t_junction_id_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_t_junction_id_patterns_, ))
    validate_t_junction_id_patterns_ = [['^(.*)$']]
    def validate_e_junction_type(self, value):
        # Validate type e_junction_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['default', 'virtual']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_junction_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.connection or
            self.priority or
            self.controller or
            self.surface is not None or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for connection_ in self.connection:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            connection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
        for priority_ in self.priority:
            namespaceprefix_ = self.priority_nsprefix_ + ':' if (UseCapturedNS_ and self.priority_nsprefix_) else ''
            priority_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priority', pretty_print=pretty_print)
        for controller_ in self.controller:
            namespaceprefix_ = self.controller_nsprefix_ + ':' if (UseCapturedNS_ and self.controller_nsprefix_) else ''
            controller_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controller', pretty_print=pretty_print)
        if self.surface is not None:
            namespaceprefix_ = self.surface_nsprefix_ + ':' if (UseCapturedNS_ and self.surface_nsprefix_) else ''
            self.surface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surface', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_t_junction_id(self.id)    # validate type t_junction_id
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_junction_type(self.type_)    # validate type e_junction_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connection':
            obj_ = t_junction_connection.factory(parent_object_=self)
            obj_.build(child_)
            self.connection.append(obj_)
            obj_.original_tagname_ = 'connection'
        elif nodeName_ == 'priority':
            obj_ = t_junction_priority.factory(parent_object_=self)
            obj_.build(child_)
            self.priority.append(obj_)
            obj_.original_tagname_ = 'priority'
        elif nodeName_ == 'controller':
            obj_ = t_junction_controller.factory(parent_object_=self)
            obj_.build(child_)
            self.controller.append(obj_)
            obj_.original_tagname_ = 'controller'
        elif nodeName_ == 'surface':
            obj_ = t_junction_surface.factory(parent_object_=self)
            obj_.build(child_)
            self.surface = obj_
            obj_.original_tagname_ = 'surface'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction


class t_junction_connection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, incomingRoad=None, connectingRoad=None, contactPoint=None, connectionMaster=None, type_=None, predecessor=None, successor=None, laneLink=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.incomingRoad = _cast(None, incomingRoad)
        self.incomingRoad_nsprefix_ = None
        self.connectingRoad = _cast(None, connectingRoad)
        self.connectingRoad_nsprefix_ = None
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
        self.connectionMaster = _cast(None, connectionMaster)
        self.connectionMaster_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if laneLink is None:
            self.laneLink = []
        else:
            self.laneLink = laneLink
        self.laneLink_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_connection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_connection.subclass:
            return t_junction_connection.subclass(*args_, **kwargs_)
        else:
            return t_junction_connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predecessor(self):
        return self.predecessor
    def set_predecessor(self, predecessor):
        self.predecessor = predecessor
    def get_successor(self):
        return self.successor
    def set_successor(self, successor):
        self.successor = successor
    def get_laneLink(self):
        return self.laneLink
    def set_laneLink(self, laneLink):
        self.laneLink = laneLink
    def add_laneLink(self, value):
        self.laneLink.append(value)
    def insert_laneLink_at(self, index, value):
        self.laneLink.insert(index, value)
    def replace_laneLink_at(self, index, value):
        self.laneLink[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_incomingRoad(self):
        return self.incomingRoad
    def set_incomingRoad(self, incomingRoad):
        self.incomingRoad = incomingRoad
    def get_connectingRoad(self):
        return self.connectingRoad
    def set_connectingRoad(self, connectingRoad):
        self.connectingRoad = connectingRoad
    def get_contactPoint(self):
        return self.contactPoint
    def set_contactPoint(self, contactPoint):
        self.contactPoint = contactPoint
    def get_connectionMaster(self):
        return self.connectionMaster
    def set_connectionMaster(self, connectionMaster):
        self.connectionMaster = connectionMaster
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_e_contactPoint(self, value):
        # Validate type e_contactPoint, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['start', 'end']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_contactPoint' % {"value" : value.encode("utf-8")} )
    def validate_e_junction_type(self, value):
        # Validate type e_junction_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['default', 'virtual']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_junction_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.laneLink or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_connection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_connection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_connection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_connection'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'incomingRoad' not in already_processed:
            already_processed.add('incomingRoad')
            outfile.write(' incomingRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.incomingRoad), input_name='incomingRoad')), ))
        if 'connectingRoad' not in already_processed:
            already_processed.add('connectingRoad')
            outfile.write(' connectingRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectingRoad), input_name='connectingRoad')), ))
        if 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
        if self.connectionMaster is not None and 'connectionMaster' not in already_processed:
            already_processed.add('connectionMaster')
            outfile.write(' connectionMaster=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectionMaster), input_name='connectionMaster')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for laneLink_ in self.laneLink:
            namespaceprefix_ = self.laneLink_nsprefix_ + ':' if (UseCapturedNS_ and self.laneLink_nsprefix_) else ''
            laneLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneLink', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('incomingRoad', node)
        if value is not None and 'incomingRoad' not in already_processed:
            already_processed.add('incomingRoad')
            self.incomingRoad = value
        value = find_attr_value_('connectingRoad', node)
        if value is not None and 'connectingRoad' not in already_processed:
            already_processed.add('connectingRoad')
            self.connectingRoad = value
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_e_contactPoint(self.contactPoint)    # validate type e_contactPoint
        value = find_attr_value_('connectionMaster', node)
        if value is not None and 'connectionMaster' not in already_processed:
            already_processed.add('connectionMaster')
            self.connectionMaster = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_junction_type(self.type_)    # validate type e_junction_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'predecessor':
            obj_ = t_junction_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = t_junction_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'laneLink':
            obj_ = t_junction_connection_laneLink.factory(parent_object_=self)
            obj_.build(child_)
            self.laneLink.append(obj_)
            obj_.original_tagname_ = 'laneLink'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_connection


class t_junction_predecessorSuccessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, elementType='road', elementId=None, elementS=None, elementDir=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.elementS = _cast(float, elementS)
        self.elementS_nsprefix_ = None
        self.elementDir = _cast(None, elementDir)
        self.elementDir_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_predecessorSuccessor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_predecessorSuccessor.subclass:
            return t_junction_predecessorSuccessor.subclass(*args_, **kwargs_)
        else:
            return t_junction_predecessorSuccessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_elementType(self):
        return self.elementType
    def set_elementType(self, elementType):
        self.elementType = elementType
    def get_elementId(self):
        return self.elementId
    def set_elementId(self, elementId):
        self.elementId = elementId
    def get_elementS(self):
        return self.elementS
    def set_elementS(self, elementS):
        self.elementS = elementS
    def get_elementDir(self):
        return self.elementDir
    def set_elementDir(self, elementDir):
        self.elementDir = elementDir
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value <= 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on t_grZero' % {"value" : value} )
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['+', '-']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_elementDir' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_predecessorSuccessor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_predecessorSuccessor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_predecessorSuccessor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_predecessorSuccessor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_predecessorSuccessor'):
        if 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
        if 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if 'elementS' not in already_processed:
            already_processed.add('elementS')
            outfile.write(' elementS="%s"' % self.gds_format_double(self.elementS, input_name='elementS'))
        if 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            outfile.write(' elementDir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementDir), input_name='elementDir')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_predecessorSuccessor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('elementS', node)
        if value is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            try:
                self.elementS = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (elementS): %s' % exp)
            self.validate_t_grZero(self.elementS)    # validate type t_grZero
        value = find_attr_value_('elementDir', node)
        if value is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            self.elementDir = value
            self.validate_e_elementDir(self.elementDir)    # validate type e_elementDir
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_predecessorSuccessor


class t_junction_connection_laneLink(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = _cast(int, from_)
        self.from__nsprefix_ = None
        self.to = _cast(int, to)
        self.to_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_connection_laneLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_connection_laneLink.subclass:
            return t_junction_connection_laneLink.subclass(*args_, **kwargs_)
        else:
            return t_junction_connection_laneLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection_laneLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_connection_laneLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_connection_laneLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_connection_laneLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_connection_laneLink'):
        if 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from="%s"' % self.gds_format_integer(self.from_, input_name='from'))
        if 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to="%s"' % self.gds_format_integer(self.to, input_name='to'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection_laneLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            try:
                self.from_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            try:
                self.to = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_connection_laneLink


class t_junction_priority(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, high=None, low=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.high = _cast(None, high)
        self.high_nsprefix_ = None
        self.low = _cast(None, low)
        self.low_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_priority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_priority.subclass:
            return t_junction_priority.subclass(*args_, **kwargs_)
        else:
            return t_junction_priority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_priority', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_priority')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_priority')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_priority', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_priority'):
        if self.high is not None and 'high' not in already_processed:
            already_processed.add('high')
            outfile.write(' high=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.high), input_name='high')), ))
        if self.low is not None and 'low' not in already_processed:
            already_processed.add('low')
            outfile.write(' low=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.low), input_name='low')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_priority', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('high', node)
        if value is not None and 'high' not in already_processed:
            already_processed.add('high')
            self.high = value
        value = find_attr_value_('low', node)
        if value is not None and 'low' not in already_processed:
            already_processed.add('low')
            self.low = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_priority


class t_junction_controller(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, sequence=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_controller)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_controller.subclass:
            return t_junction_controller.subclass(*args_, **kwargs_)
        else:
            return t_junction_controller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_controller', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_controller')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_controller')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_controller', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_controller'):
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_controller', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            try:
                self.sequence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.sequence < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_controller


class t_junction_surface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CRG=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CRG is None:
            self.CRG = []
        else:
            self.CRG = CRG
        self.CRG_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_surface.subclass:
            return t_junction_surface.subclass(*args_, **kwargs_)
        else:
            return t_junction_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CRG(self):
        return self.CRG
    def set_CRG(self, CRG):
        self.CRG = CRG
    def add_CRG(self, value):
        self.CRG.append(value)
    def insert_CRG_at(self, index, value):
        self.CRG.insert(index, value)
    def replace_CRG_at(self, index, value):
        self.CRG[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def hasContent_(self):
        if (
            self.CRG or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_surface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_surface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_surface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_surface'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CRG_ in self.CRG:
            namespaceprefix_ = self.CRG_nsprefix_ + ':' if (UseCapturedNS_ and self.CRG_nsprefix_) else ''
            CRG_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRG', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CRG':
            obj_ = t_junction_surface_CRG.factory(parent_object_=self)
            obj_.build(child_)
            self.CRG.append(obj_)
            obj_.original_tagname_ = 'CRG'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_surface


class t_junction_surface_CRG(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file=None, mode='global', purpose=None, zOffset=None, zScale=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.mode = _cast(None, mode)
        self.mode_nsprefix_ = None
        self.purpose = _cast(None, purpose)
        self.purpose_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.zScale = _cast(float, zScale)
        self.zScale_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_surface_CRG)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_surface_CRG.subclass:
            return t_junction_surface_CRG.subclass(*args_, **kwargs_)
        else:
            return t_junction_surface_CRG(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def get_zOffset(self):
        return self.zOffset
    def set_zOffset(self, zOffset):
        self.zOffset = zOffset
    def get_zScale(self):
        return self.zScale
    def set_zScale(self, zScale):
        self.zScale = zScale
    def validate_e_road_surface_CRG_mode(self, value):
        # Validate type e_road_surface_CRG_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['attached', 'attached0', 'genuine', 'global']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_surface_CRG_mode' % {"value" : value.encode("utf-8")} )
    def validate_e_road_surface_CRG_purpose(self, value):
        # Validate type e_road_surface_CRG_purpose, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['elevation', 'friction']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_road_surface_CRG_purpose' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface_CRG', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_surface_CRG')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_surface_CRG')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_surface_CRG', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_surface_CRG'):
        if 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')), ))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.zScale is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            outfile.write(' zScale="%s"' % self.gds_format_double(self.zScale, input_name='zScale'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface_CRG', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_e_road_surface_CRG_mode(self.mode)    # validate type e_road_surface_CRG_mode
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
            self.validate_e_road_surface_CRG_purpose(self.purpose)    # validate type e_road_surface_CRG_purpose
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            try:
                self.zOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zOffset): %s' % exp)
        value = find_attr_value_('zScale', node)
        if value is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            try:
                self.zScale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zScale): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junction_surface_CRG


class t_junctionGroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, type_=None, junctionReference=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if junctionReference is None:
            self.junctionReference = []
        else:
            self.junctionReference = junctionReference
        self.junctionReference_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junctionGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junctionGroup.subclass:
            return t_junctionGroup.subclass(*args_, **kwargs_)
        else:
            return t_junctionGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_junctionReference(self):
        return self.junctionReference
    def set_junctionReference(self, junctionReference):
        self.junctionReference = junctionReference
    def add_junctionReference(self, value):
        self.junctionReference.append(value)
    def insert_junctionReference_at(self, index, value):
        self.junctionReference.insert(index, value)
    def replace_junctionReference_at(self, index, value):
        self.junctionReference[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_e_junctionGroup_type(self, value):
        # Validate type e_junctionGroup_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['roundabout', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_junctionGroup_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.junctionReference or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junctionGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junctionGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junctionGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junctionGroup'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for junctionReference_ in self.junctionReference:
            namespaceprefix_ = self.junctionReference_nsprefix_ + ':' if (UseCapturedNS_ and self.junctionReference_nsprefix_) else ''
            junctionReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junctionReference', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_junctionGroup_type(self.type_)    # validate type e_junctionGroup_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'junctionReference':
            obj_ = t_junctionGroup_junctionReference.factory(parent_object_=self)
            obj_.build(child_)
            self.junctionReference.append(obj_)
            obj_.original_tagname_ = 'junctionReference'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junctionGroup


class t_junctionGroup_junctionReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, junction=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.junction = _cast(None, junction)
        self.junction_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junctionGroup_junctionReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junctionGroup_junctionReference.subclass:
            return t_junctionGroup_junctionReference.subclass(*args_, **kwargs_)
        else:
            return t_junctionGroup_junctionReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_junction(self):
        return self.junction
    def set_junction(self, junction):
        self.junction = junction
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup_junctionReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junctionGroup_junctionReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junctionGroup_junctionReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junctionGroup_junctionReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junctionGroup_junctionReference'):
        if 'junction' not in already_processed:
            already_processed.add('junction')
            outfile.write(' junction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.junction), input_name='junction')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup_junctionReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('junction', node)
        if value is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            self.junction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_junctionGroup_junctionReference


class t_station(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, type_=None, platform=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_station)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_station.subclass:
            return t_station.subclass(*args_, **kwargs_)
        else:
            return t_station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_e_station_type(self, value):
        # Validate type e_station_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['small', 'medium', 'large']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_station_type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.platform or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_station')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_station', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_station'):
        if 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_station_type(self.type_)    # validate type e_station_type
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'platform':
            obj_ = t_station_platform.factory(parent_object_=self)
            obj_.build(child_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_station


class t_station_platform(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, segment=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.segment_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_station_platform)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_station_platform.subclass:
            return t_station_platform.subclass(*args_, **kwargs_)
        else:
            return t_station_platform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_segment(self):
        return self.segment
    def set_segment(self, segment):
        self.segment = segment
    def add_segment(self, value):
        self.segment.append(value)
    def insert_segment_at(self, index, value):
        self.segment.insert(index, value)
    def replace_segment_at(self, index, value):
        self.segment[index] = value
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.segment or
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_station_platform')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station_platform')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_station_platform', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_station_platform'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            namespaceprefix_ = self.segment_nsprefix_ + ':' if (UseCapturedNS_ and self.segment_nsprefix_) else ''
            segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segment', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = t_station_platform_segment.factory(parent_object_=self)
            obj_.build(child_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_station_platform


class t_station_platform_segment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, roadId=None, sStart=None, sEnd=None, side=None, userData=None, include=None, dataQuality=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.roadId = _cast(None, roadId)
        self.roadId_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_station_platform_segment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_station_platform_segment.subclass:
            return t_station_platform_segment.subclass(*args_, **kwargs_)
        else:
            return t_station_platform_segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_userData(self):
        return self.userData
    def set_userData(self, userData):
        self.userData = userData
    def add_userData(self, value):
        self.userData.append(value)
    def insert_userData_at(self, index, value):
        self.userData.insert(index, value)
    def replace_userData_at(self, index, value):
        self.userData[index] = value
    def get_include(self):
        return self.include
    def set_include(self, include):
        self.include = include
    def add_include(self, value):
        self.include.append(value)
    def insert_include_at(self, index, value):
        self.include.insert(index, value)
    def replace_include_at(self, index, value):
        self.include[index] = value
    def get_dataQuality(self):
        return self.dataQuality
    def set_dataQuality(self, dataQuality):
        self.dataQuality = dataQuality
    def get_roadId(self):
        return self.roadId
    def set_roadId(self, roadId):
        self.roadId = roadId
    def get_sStart(self):
        return self.sStart
    def set_sStart(self, sStart):
        self.sStart = sStart
    def get_sEnd(self):
        return self.sEnd
    def set_sEnd(self, sEnd):
        self.sEnd = sEnd
    def get_side(self):
        return self.side
    def set_side(self, side):
        self.side = side
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on t_grEqZero' % {"value" : value} )
    def validate_e_station_platform_segment_side(self, value):
        # Validate type e_station_platform_segment_side, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['left', 'right']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_station_platform_segment_side' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.userData or
            self.include or
            self.dataQuality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform_segment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_station_platform_segment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station_platform_segment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_station_platform_segment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_station_platform_segment'):
        if 'roadId' not in already_processed:
            already_processed.add('roadId')
            outfile.write(' roadId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.roadId), input_name='roadId')), ))
        if 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
        if 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform_segment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        if self.dataQuality is not None:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            self.dataQuality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roadId', node)
        if value is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            self.roadId = value
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            try:
                self.sStart = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sStart): %s' % exp)
            self.validate_t_grEqZero(self.sStart)    # validate type t_grEqZero
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            try:
                self.sEnd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sEnd): %s' % exp)
            self.validate_t_grEqZero(self.sEnd)    # validate type t_grEqZero
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_e_station_platform_segment_side(self.side)    # validate type e_station_platform_segment_side
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_)
            self.dataQuality = obj_
            obj_.original_tagname_ = 'dataQuality'
# end class t_station_platform_segment


class t_userData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, value=None, anytypeobjs_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_userData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_userData.subclass:
            return t_userData.subclass(*args_, **kwargs_)
        else:
            return t_userData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_userData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_userData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_userData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_userData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_userData'):
        if 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_userData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        content_ = self.gds_build_any(child_, 't_userData')
        self.add_anytypeobjs_(content_)
# end class t_userData


class t_include(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_include)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_include.subclass:
            return t_include.subclass(*args_, **kwargs_)
        else:
            return t_include(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_include', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_include')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_include')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_include', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_include'):
        if 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_include', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class t_include


class t_dataQuality(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, error=None, rawData=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.error = error
        self.error_nsprefix_ = None
        self.rawData = rawData
        self.rawData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality.subclass:
            return t_dataQuality.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_error(self):
        return self.error
    def set_error(self, error):
        self.error = error
    def get_rawData(self):
        return self.rawData
    def set_rawData(self, rawData):
        self.rawData = rawData
    def hasContent_(self):
        if (
            self.error is not None or
            self.rawData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.error is not None:
            namespaceprefix_ = self.error_nsprefix_ + ':' if (UseCapturedNS_ and self.error_nsprefix_) else ''
            self.error.export(outfile, level, namespaceprefix_, namespacedef_='', name_='error', pretty_print=pretty_print)
        if self.rawData is not None:
            namespaceprefix_ = self.rawData_nsprefix_ + ':' if (UseCapturedNS_ and self.rawData_nsprefix_) else ''
            self.rawData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rawData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'error':
            obj_ = t_dataQuality_Error.factory(parent_object_=self)
            obj_.build(child_)
            self.error = obj_
            obj_.original_tagname_ = 'error'
        elif nodeName_ == 'rawData':
            obj_ = t_dataQuality_RawData.factory(parent_object_=self)
            obj_.build(child_)
            self.rawData = obj_
            obj_.original_tagname_ = 'rawData'
# end class t_dataQuality


class t_dataQuality_Error(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xyAbsolute=None, zAbsolute=None, xyRelative=None, zRelative=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xyAbsolute = _cast(float, xyAbsolute)
        self.xyAbsolute_nsprefix_ = None
        self.zAbsolute = _cast(float, zAbsolute)
        self.zAbsolute_nsprefix_ = None
        self.xyRelative = _cast(float, xyRelative)
        self.xyRelative_nsprefix_ = None
        self.zRelative = _cast(float, zRelative)
        self.zRelative_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality_Error)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality_Error.subclass:
            return t_dataQuality_Error.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality_Error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xyAbsolute(self):
        return self.xyAbsolute
    def set_xyAbsolute(self, xyAbsolute):
        self.xyAbsolute = xyAbsolute
    def get_zAbsolute(self):
        return self.zAbsolute
    def set_zAbsolute(self, zAbsolute):
        self.zAbsolute = zAbsolute
    def get_xyRelative(self):
        return self.xyRelative
    def set_xyRelative(self, xyRelative):
        self.xyRelative = xyRelative
    def get_zRelative(self):
        return self.zRelative
    def set_zRelative(self, zRelative):
        self.zRelative = zRelative
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_Error', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality_Error')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality_Error')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality_Error', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality_Error'):
        if 'xyAbsolute' not in already_processed:
            already_processed.add('xyAbsolute')
            outfile.write(' xyAbsolute="%s"' % self.gds_format_double(self.xyAbsolute, input_name='xyAbsolute'))
        if 'zAbsolute' not in already_processed:
            already_processed.add('zAbsolute')
            outfile.write(' zAbsolute="%s"' % self.gds_format_double(self.zAbsolute, input_name='zAbsolute'))
        if 'xyRelative' not in already_processed:
            already_processed.add('xyRelative')
            outfile.write(' xyRelative="%s"' % self.gds_format_double(self.xyRelative, input_name='xyRelative'))
        if 'zRelative' not in already_processed:
            already_processed.add('zRelative')
            outfile.write(' zRelative="%s"' % self.gds_format_double(self.zRelative, input_name='zRelative'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_Error', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xyAbsolute', node)
        if value is not None and 'xyAbsolute' not in already_processed:
            already_processed.add('xyAbsolute')
            try:
                self.xyAbsolute = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xyAbsolute): %s' % exp)
        value = find_attr_value_('zAbsolute', node)
        if value is not None and 'zAbsolute' not in already_processed:
            already_processed.add('zAbsolute')
            try:
                self.zAbsolute = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zAbsolute): %s' % exp)
        value = find_attr_value_('xyRelative', node)
        if value is not None and 'xyRelative' not in already_processed:
            already_processed.add('xyRelative')
            try:
                self.xyRelative = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xyRelative): %s' % exp)
        value = find_attr_value_('zRelative', node)
        if value is not None and 'zRelative' not in already_processed:
            already_processed.add('zRelative')
            try:
                self.zRelative = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zRelative): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class t_dataQuality_Error


class t_dataQuality_RawData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, date=None, source=None, sourceComment=None, postProcessing=None, postProcessingComment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.sourceComment = _cast(None, sourceComment)
        self.sourceComment_nsprefix_ = None
        self.postProcessing = _cast(None, postProcessing)
        self.postProcessing_nsprefix_ = None
        self.postProcessingComment = _cast(None, postProcessingComment)
        self.postProcessingComment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality_RawData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality_RawData.subclass:
            return t_dataQuality_RawData.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality_RawData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_sourceComment(self):
        return self.sourceComment
    def set_sourceComment(self, sourceComment):
        self.sourceComment = sourceComment
    def get_postProcessing(self):
        return self.postProcessing
    def set_postProcessing(self, postProcessing):
        self.postProcessing = postProcessing
    def get_postProcessingComment(self):
        return self.postProcessingComment
    def set_postProcessingComment(self, postProcessingComment):
        self.postProcessingComment = postProcessingComment
    def validate_e_dataQuality_RawData_Source(self, value):
        # Validate type e_dataQuality_RawData_Source, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['sensor', 'cadaster', 'custom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_dataQuality_RawData_Source' % {"value" : value.encode("utf-8")} )
    def validate_e_dataQuality_RawData_PostProcessing(self, value):
        # Validate type e_dataQuality_RawData_PostProcessing, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['raw', 'cleaned', 'processed', 'fused']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on e_dataQuality_RawData_PostProcessing' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_RawData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality_RawData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality_RawData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality_RawData', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality_RawData'):
        if 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.sourceComment is not None and 'sourceComment' not in already_processed:
            already_processed.add('sourceComment')
            outfile.write(' sourceComment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sourceComment), input_name='sourceComment')), ))
        if 'postProcessing' not in already_processed:
            already_processed.add('postProcessing')
            outfile.write(' postProcessing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postProcessing), input_name='postProcessing')), ))
        if self.postProcessingComment is not None and 'postProcessingComment' not in already_processed:
            already_processed.add('postProcessingComment')
            outfile.write(' postProcessingComment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postProcessingComment), input_name='postProcessingComment')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_RawData', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
            self.validate_e_dataQuality_RawData_Source(self.source)    # validate type e_dataQuality_RawData_Source
        value = find_attr_value_('sourceComment', node)
        if value is not None and 'sourceComment' not in already_processed:
            already_processed.add('sourceComment')
            self.sourceComment = value
        value = find_attr_value_('postProcessing', node)
        if value is not None and 'postProcessing' not in already_processed:
            already_processed.add('postProcessing')
            self.postProcessing = value
            self.validate_e_dataQuality_RawData_PostProcessing(self.postProcessing)    # validate type e_dataQuality_RawData_PostProcessing
        value = find_attr_value_('postProcessingComment', node)
        if value is not None and 'postProcessingComment' not in already_processed:
            already_processed.add('postProcessingComment')
            self.postProcessingComment = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class t_dataQuality_RawData


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False):
    global CapturedNsmap_
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OpenDRIVE'
        rootClass = OpenDRIVE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from opendrive_parser_15M import *\n\n')
        sys.stdout.write('import opendrive_parser_15M as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "OpenDRIVE",
    "t_controller",
    "t_controller_control",
    "t_dataQuality",
    "t_dataQuality_Error",
    "t_dataQuality_RawData",
    "t_header",
    "t_header_GeoReference",
    "t_header_Offset",
    "t_include",
    "t_junction",
    "t_junctionGroup",
    "t_junctionGroup_junctionReference",
    "t_junction_connection",
    "t_junction_connection_laneLink",
    "t_junction_controller",
    "t_junction_predecessorSuccessor",
    "t_junction_priority",
    "t_junction_surface",
    "t_junction_surface_CRG",
    "t_road",
    "t_road_elevationProfile",
    "t_road_elevationProfile_elevation",
    "t_road_lanes",
    "t_road_lanes_laneOffset",
    "t_road_lanes_laneSection",
    "t_road_lanes_laneSection_center",
    "t_road_lanes_laneSection_center_lane",
    "t_road_lanes_laneSection_lcr_lane_link",
    "t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor",
    "t_road_lanes_laneSection_lcr_lane_roadMark",
    "t_road_lanes_laneSection_lcr_lane_roadMark_explicit",
    "t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line",
    "t_road_lanes_laneSection_lcr_lane_roadMark_sway",
    "t_road_lanes_laneSection_lcr_lane_roadMark_type",
    "t_road_lanes_laneSection_lcr_lane_roadMark_type_line",
    "t_road_lanes_laneSection_left",
    "t_road_lanes_laneSection_left_lane",
    "t_road_lanes_laneSection_lr_lane",
    "t_road_lanes_laneSection_lr_lane_access",
    "t_road_lanes_laneSection_lr_lane_border",
    "t_road_lanes_laneSection_lr_lane_height",
    "t_road_lanes_laneSection_lr_lane_material",
    "t_road_lanes_laneSection_lr_lane_rule",
    "t_road_lanes_laneSection_lr_lane_speed",
    "t_road_lanes_laneSection_lr_lane_visibility",
    "t_road_lanes_laneSection_lr_lane_width",
    "t_road_lanes_laneSection_right",
    "t_road_lanes_laneSection_right_lane",
    "t_road_lateralProfile",
    "t_road_lateralProfile_crossfall",
    "t_road_lateralProfile_shape",
    "t_road_lateralProfile_superelevation",
    "t_road_link",
    "t_road_link_neighbor",
    "t_road_link_predecessorSuccessor",
    "t_road_objects",
    "t_road_objects_bridge",
    "t_road_objects_object",
    "t_road_objects_objectReference",
    "t_road_objects_object_borders",
    "t_road_objects_object_borders_border",
    "t_road_objects_object_laneValidity",
    "t_road_objects_object_markings",
    "t_road_objects_object_markings_marking",
    "t_road_objects_object_markings_marking_cornerReference",
    "t_road_objects_object_material",
    "t_road_objects_object_outlines",
    "t_road_objects_object_outlines_outline",
    "t_road_objects_object_outlines_outline_cornerLocal",
    "t_road_objects_object_outlines_outline_cornerRoad",
    "t_road_objects_object_parkingSpace",
    "t_road_objects_object_repeat",
    "t_road_objects_tunnel",
    "t_road_planView",
    "t_road_planView_geometry",
    "t_road_planView_geometry_arc",
    "t_road_planView_geometry_line",
    "t_road_planView_geometry_paramPoly3",
    "t_road_planView_geometry_poly3",
    "t_road_planView_geometry_spiral",
    "t_road_railroad",
    "t_road_railroad_switch",
    "t_road_railroad_switch_mainTrack",
    "t_road_railroad_switch_partner",
    "t_road_railroad_switch_sideTrack",
    "t_road_signals",
    "t_road_signals_signal",
    "t_road_signals_signalReference",
    "t_road_signals_signal_dependency",
    "t_road_signals_signal_positionInertial",
    "t_road_signals_signal_positionRoad",
    "t_road_signals_signal_reference",
    "t_road_surface",
    "t_road_surface_CRG",
    "t_road_type",
    "t_road_type_speed",
    "t_station",
    "t_station_platform",
    "t_station_platform_segment",
    "t_userData"
]
